{"version":3,"sources":["webpack:////home/travis/build/xmlking/ngx-starter-kit/libs/breadcrumbs/src/lib/breadcrumbs.module.ts","webpack:////home/travis/build/xmlking/ngx-starter-kit/libs/breadcrumbs/src/lib/breadcrumbs.component.ts","webpack:////home/travis/build/xmlking/ngx-starter-kit/node_modules/@angular/cdk/esm5/drag-drop.es5.js.pre-build-optimizer.js","webpack:////home/travis/build/xmlking/ngx-starter-kit/libs/breadcrumbs/src/lib/breadcrumbs.component.scss.shim.ngstyle.js.pre-build-optimizer.js","webpack:////home/travis/build/xmlking/ngx-starter-kit/libs/breadcrumbs/src/lib/breadcrumbs.component.ngfactory.js.pre-build-optimizer.js","webpack:////home/travis/build/xmlking/ngx-starter-kit/libs/breadcrumbs/src/lib/breadcrumbs.component.html"],"names":["__webpack_require__","d","__webpack_exports__","BreadcrumbsModule","BreadcrumbsComponent","prototype","ngOnInit","DragDrop","CdkDropList","CDK_DROP_LIST","moveItemInArray","DragDropModule","DragDropRegistry","CdkDropListGroup","CDK_DRAG_CONFIG","CdkDrag","CdkDragHandle","CDK_DRAG_PARENT","_angular_cdk_platform__WEBPACK_IMPORTED_MODULE_0__","_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_1__","rxjs__WEBPACK_IMPORTED_MODULE_2__","rxjs__WEBPACK_IMPORTED_MODULE_3__","rxjs__WEBPACK_IMPORTED_MODULE_4__","rxjs__WEBPACK_IMPORTED_MODULE_5__","_angular_core__WEBPACK_IMPORTED_MODULE_6__","_angular_common__WEBPACK_IMPORTED_MODULE_7__","_angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_8__","rxjs_operators__WEBPACK_IMPORTED_MODULE_9__","rxjs_operators__WEBPACK_IMPORTED_MODULE_10__","rxjs_operators__WEBPACK_IMPORTED_MODULE_11__","rxjs_operators__WEBPACK_IMPORTED_MODULE_12__","rxjs_operators__WEBPACK_IMPORTED_MODULE_13__","rxjs_operators__WEBPACK_IMPORTED_MODULE_14__","extendStyles","dest","source","key","hasOwnProperty","toggleNativeDragInteractions","element","enable","userSelect","style","touchAction","webkitUserDrag","webkitTapHighlightColor","msUserSelect","webkitUserSelect","MozUserSelect","parseCssTimeUnitsToMs","value","multiplier","toLowerCase","indexOf","parseFloat","parseCssPropertyValue","computedStyle","name","getPropertyValue","split","map","part","trim","passiveEventListenerOptions","Object","passive","activeEventListenerOptions","DragRef","_config","_document","_ngZone","_viewportRuler","_dragDropRegistry","_this","this","_passiveTransform","x","y","_activeTransform","_moveEvents","_moveEventSubscriptions","_pointerMoveSubscription","EMPTY","_pointerUpSubscription","_boundaryElement","_nativeInteractionsEnabled","_handles","_disabledHandles","Set","_direction","_disabled","beforeStarted","started","released","ended","entered","exited","dropped","moved","observer","subscription","subscribe","unsubscribe","_pointerDown","event","next","length","targetHandle","find","handle","target","contains","has","disabled","_initializeDragSequence","_rootElement","_pointerMove","_hasStartedDragging","_previewRect","width","height","_preview","getBoundingClientRect","constrainedPointerPosition","_getConstrainedPointerPosition","_hasMoved","preventDefault","_updatePointerDirectionDelta","_dropContainer","_updateActiveDropContainer","activeTransform","_pickupPositionOnPage","transform","getTransform","_initialTransform","SVGElement","setAttribute","run","pointerPosition","delta","_pointerDirectionDelta","_getPointerPositionOnPage","Math","abs","dragStartThreshold","_startDragSequence","_pointerUp","isDragging","_removeSubscriptions","stopDragging","_rootElementTapHighlight","_animatePreviewToPlaceholder","then","_cleanupDragArtifacts","withRootElement","registerDragItem","defineProperty","get","set","newValue","_toggleNativeDragInteractions","enumerable","configurable","getPlaceholderElement","_placeholder","getRootElement","withHandles","handles","forEach","withPreviewTemplate","template","_previewTemplate","withPlaceholderTemplate","_placeholderTemplate","rootElement","_removeRootElementListeners","addEventListener","undefined","withBoundaryElement","boundaryElement","dispose","removeElement","_destroyPreview","_destroyPlaceholder","removeDragItem","complete","clear","_nextSibling","reset","disableHandle","add","enableHandle","delete","withDirection","direction","_withDropContainer","container","_previewRef","destroy","_placeholderRef","isTouchEvent","_lastTouchEventTime","Date","now","nextSibling","preview","_createPreviewElement","placeholder","_createPlaceholderElement","display","body","appendChild","replaceChild","start","referenceElement","stopPropagation","isTouchSequence","isAuxiliaryMouseButton","button","isSyntheticEvent","draggable","type","_initialContainer","pointerMove","pointerUp","_scrollPosition","getViewportScrollPosition","_boundaryRect","_pickupPositionInElement","_getPointerPositionInElement","_pointerPositionAtLastDirectionChange","startDragging","insertBefore","currentIndex","getItemIndex","_a","isPointerOverContainer","_isOverContainer","item","previousIndex","previousContainer","drop","newContainer","_getSiblingContainerFromPosition","exit","enter","_sortItem","previewConfig","previewTemplate","viewRef","viewContainer","createEmbeddedView","context","rootNodes","elementRect","deepCloneNode","left","top","pointerEvents","position","zIndex","classList","Promise","resolve","placeholderRect","duration","getComputedStyle","transitionedProperties","property","prop","propertyIndex","rawDurations","rawDelays","getTransformTransitionDurationInMs","runOutsideAngular","handler","propertyName","removeEventListener","clearTimeout","timeout","setTimeout","placeholderConfig","placeholderTemplate","handleElement","referenceRect","point","targetTouches","pageX","pageY","touches","changedTouches","dropContainerLock","lockAxis","pickupX","pickupY","boundaryRect","previewRect","minY","maxY","bottom","clamp","right","pointerPositionOnPage","positionSinceLastChange","changeX","changeY","pointerDirectionChangeThreshold","shouldEnable","round","node","clone","cloneNode","removeAttribute","min","max","parentNode","removeChild","startsWith","array","fromIndex","toIndex","from","clamp$1","to","i","_uniqueIdCounter","DropListRef","id","enterPredicate","sorted","_isDragging","_itemPositions","_previousSwap","drag","_siblings","_orientation","_activeSiblings","registerDropContainer","nativeElement","removeDropContainer","_activeDraggables","_draggables","slice","_cacheOwnPosition","_cacheItemPositions","sibling","_startReceiving","pointerX","pointerY","newIndex","_getItemIndexFromPointerPosition","newPositionReference","splice","push","_reset","withItems","items","connectedTo","withOrientation","orientation","findIndex","reverse","currentItem","isReceiving","size","pointerDelta","_isPointerNearDropContainer","siblings","isHorizontal","siblingAtNewPosition","currentPosition","clientRect","newPosition","itemOffset","_getItemOffsetPx","siblingOffset","_getSiblingOffsetPx","oldOrder","index","isDraggedItem","offset","elementToOffset","adjustClientRect","_clientRect","sort","a","b","_stopReceiving","immediateSibling","end","xThreshold","yThreshold","_","floor","isInsideClientRect","_canReceive","elementFromPoint","activeSiblings","predicate","activeCapturingEventOptions","capture","_dropInstances","_dragInstances","_activeDragInstances","_globalListeners","Map","_preventDefaultWhileDragging","getDropContainer","Error","upEvent","e","options","config","_clearGlobalListeners","Array","instance","ngOnDestroy","ngInjectableDef","factory","token","providedIn","DEFAULT_CONFIG","createDrag","createDropList","parentDrag","_stateChanges","_parentDrag","dropContainer","_viewContainerRef","viewportRuler","dragDropRegistry","_dir","dragDrop","_changeDetectorRef","_destroyed","_dragRef","pipe","movedEvent","data","_syncInputs","_handleEvents","ngAfterViewInit","onStable","asObservable","_updateRootElement","changes","childHandleElements","filter","apply","handleInstance","dragRef","ngOnChanges","rootSelectorChange","firstChange","rootElementSelector","getClosestMatchingAncestor","nodeType","ELEMENT_NODE","nodeName","_getBoundaryElement","selector","boundaryElementSelector","ref","dir","templateRef","emit","markForCheck","currentElement","matches","msMatchesSelector","parentElement","_items","_uniqueIdCounter$1","_group","_dropListRef","document","_dropLists","ngAfterContentInit","result","change","list","RenderType_BreadcrumbsComponent","View_BreadcrumbsComponent_0","core","encapsulation","styles","View_BreadcrumbsComponent_2","_l","_v","en","$event","ad","onClick","ctrlKey","metaKey","shiftKey","router","common","routerLink","_ck","currVal_2","parent","$implicit","link","href","View_BreadcrumbsComponent_3","View_BreadcrumbsComponent_4","index_ngfactory","icon_es5","inline","color","View_BreadcrumbsComponent_1","flex_es5","core_es5","fxLayout","fxLayoutAlign","ngSwitch","ngSwitchCase","ngIf","last","ngForOf","_co","component","crumbs","title"],"mappings":"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","file":"8.785e01338eb29da2485e.js","sourcesContent":["import { NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { BreadcrumbsComponent } from './breadcrumbs.component';\nimport { MatIconModule } from '@angular/material';\nimport { RouterModule } from '@angular/router';\nimport { FlexLayoutModule } from '@angular/flex-layout';\n\n@NgModule({\n  imports: [MatIconModule, FlexLayoutModule, RouterModule, CommonModule],\n  exports: [BreadcrumbsComponent],\n  declarations: [BreadcrumbsComponent],\n})\nexport class BreadcrumbsModule {}\n","import { ChangeDetectionStrategy, Component, Input, OnInit } from '@angular/core';\n\nexport interface Crumb {\n  name: string;\n  link?: string;\n}\n@Component({\n  selector: 'ngx-breadcrumbs',\n  templateUrl: './breadcrumbs.component.html',\n  styleUrls: ['./breadcrumbs.component.scss'],\n  changeDetection: ChangeDetectionStrategy.OnPush,\n})\nexport class BreadcrumbsComponent implements OnInit {\n  @Input()\n  readonly title: string;\n  @Input()\n  crumbs: ReadonlyArray<Crumb>;\n\n  constructor() {}\n\n  ngOnInit() {}\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { normalizePassiveListenerOptions } from '@angular/cdk/platform';\nimport { coerceBooleanProperty, coerceElement, coerceArray } from '@angular/cdk/coercion';\nimport { Subscription, Subject, Observable, merge } from 'rxjs';\nimport { ElementRef, Injectable, NgZone, Inject, InjectionToken, NgModule, ContentChildren, EventEmitter, forwardRef, Input, Output, Optional, Directive, ChangeDetectorRef, SkipSelf, ContentChild, ViewContainerRef, TemplateRef, defineInjectable, inject } from '@angular/core';\nimport { DOCUMENT } from '@angular/common';\nimport { ViewportRuler } from '@angular/cdk/scrolling';\nimport { Directionality } from '@angular/cdk/bidi';\nimport { startWith, take, map, takeUntil, switchMap, tap } from 'rxjs/operators';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Shallow-extends a stylesheet object with another stylesheet object.\n * \\@docs-private\n * @param {?} dest\n * @param {?} source\n * @return {?}\n */\nfunction extendStyles(dest, source) {\n    for (var key in source) {\n        if (source.hasOwnProperty(key)) {\n            dest[(/** @type {?} */ (key))] = source[(/** @type {?} */ (key))];\n        }\n    }\n    return dest;\n}\n/**\n * Toggles whether the native drag interactions should be enabled for an element.\n * \\@docs-private\n * @param {?} element Element on which to toggle the drag interactions.\n * @param {?} enable Whether the drag interactions should be enabled.\n * @return {?}\n */\nfunction toggleNativeDragInteractions(element, enable) {\n    /** @type {?} */\n    var userSelect = enable ? '' : 'none';\n    extendStyles(element.style, {\n        touchAction: enable ? '' : 'none',\n        webkitUserDrag: enable ? '' : 'none',\n        webkitTapHighlightColor: enable ? '' : 'transparent',\n        userSelect: userSelect,\n        msUserSelect: userSelect,\n        webkitUserSelect: userSelect,\n        MozUserSelect: userSelect\n    });\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Parses a CSS time value to milliseconds.\n * @param {?} value\n * @return {?}\n */\nfunction parseCssTimeUnitsToMs(value) {\n    // Some browsers will return it in seconds, whereas others will return milliseconds.\n    /** @type {?} */\n    var multiplier = value.toLowerCase().indexOf('ms') > -1 ? 1 : 1000;\n    return parseFloat(value) * multiplier;\n}\n/**\n * Gets the transform transition duration, including the delay, of an element in milliseconds.\n * @param {?} element\n * @return {?}\n */\nfunction getTransformTransitionDurationInMs(element) {\n    /** @type {?} */\n    var computedStyle = getComputedStyle(element);\n    /** @type {?} */\n    var transitionedProperties = parseCssPropertyValue(computedStyle, 'transition-property');\n    /** @type {?} */\n    var property = transitionedProperties.find(function (prop) { return prop === 'transform' || prop === 'all'; });\n    // If there's no transition for `all` or `transform`, we shouldn't do anything.\n    if (!property) {\n        return 0;\n    }\n    // Get the index of the property that we're interested in and match\n    // it up to the same index in `transition-delay` and `transition-duration`.\n    /** @type {?} */\n    var propertyIndex = transitionedProperties.indexOf(property);\n    /** @type {?} */\n    var rawDurations = parseCssPropertyValue(computedStyle, 'transition-duration');\n    /** @type {?} */\n    var rawDelays = parseCssPropertyValue(computedStyle, 'transition-delay');\n    return parseCssTimeUnitsToMs(rawDurations[propertyIndex]) +\n        parseCssTimeUnitsToMs(rawDelays[propertyIndex]);\n}\n/**\n * Parses out multiple values from a computed style into an array.\n * @param {?} computedStyle\n * @param {?} name\n * @return {?}\n */\nfunction parseCssPropertyValue(computedStyle, name) {\n    /** @type {?} */\n    var value = computedStyle.getPropertyValue(name);\n    return value.split(',').map(function (part) { return part.trim(); });\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Options that can be used to bind a passive event listener.\n * @type {?}\n */\nvar passiveEventListenerOptions = normalizePassiveListenerOptions({ passive: true });\n/**\n * Options that can be used to bind an active event listener.\n * @type {?}\n */\nvar activeEventListenerOptions = normalizePassiveListenerOptions({ passive: false });\n/**\n * Time in milliseconds for which to ignore mouse events, after\n * receiving a touch event. Used to avoid doing double work for\n * touch devices where the browser fires fake mouse events, in\n * addition to touch events.\n * @type {?}\n */\nvar MOUSE_EVENT_IGNORE_TIME = 800;\n/**\n * Reference to a draggable item. Used to manipulate or dispose of the item.\n * \\@docs-private\n * @template T\n */\nvar  /**\n * Reference to a draggable item. Used to manipulate or dispose of the item.\n * \\@docs-private\n * @template T\n */\nDragRef = /** @class */ (function () {\n    function DragRef(element, _config, _document, _ngZone, _viewportRuler, _dragDropRegistry) {\n        var _this = this;\n        this._config = _config;\n        this._document = _document;\n        this._ngZone = _ngZone;\n        this._viewportRuler = _viewportRuler;\n        this._dragDropRegistry = _dragDropRegistry;\n        /**\n         * CSS `transform` applied to the element when it isn't being dragged. We need a\n         * passive transform in order for the dragged element to retain its new position\n         * after the user has stopped dragging and because we need to know the relative\n         * position in case they start dragging again. This corresponds to `element.style.transform`.\n         */\n        this._passiveTransform = { x: 0, y: 0 };\n        /**\n         * CSS `transform` that is applied to the element while it's being dragged.\n         */\n        this._activeTransform = { x: 0, y: 0 };\n        /**\n         * Emits when the item is being moved.\n         */\n        this._moveEvents = new Subject();\n        /**\n         * Amount of subscriptions to the move event. Used to avoid\n         * hitting the zone if the consumer didn't subscribe to it.\n         */\n        this._moveEventSubscriptions = 0;\n        /**\n         * Subscription to pointer movement events.\n         */\n        this._pointerMoveSubscription = Subscription.EMPTY;\n        /**\n         * Subscription to the event that is dispatched when the user lifts their pointer.\n         */\n        this._pointerUpSubscription = Subscription.EMPTY;\n        /**\n         * Cached reference to the boundary element.\n         */\n        this._boundaryElement = null;\n        /**\n         * Whether the native dragging interactions have been enabled on the root element.\n         */\n        this._nativeInteractionsEnabled = true;\n        /**\n         * Elements that can be used to drag the draggable item.\n         */\n        this._handles = [];\n        /**\n         * Registered handles that are currently disabled.\n         */\n        this._disabledHandles = new Set();\n        /**\n         * Layout direction of the item.\n         */\n        this._direction = 'ltr';\n        this._disabled = false;\n        /**\n         * Emits as the drag sequence is being prepared.\n         */\n        this.beforeStarted = new Subject();\n        /**\n         * Emits when the user starts dragging the item.\n         */\n        this.started = new Subject();\n        /**\n         * Emits when the user has released a drag item, before any animations have started.\n         */\n        this.released = new Subject();\n        /**\n         * Emits when the user stops dragging an item in the container.\n         */\n        this.ended = new Subject();\n        /**\n         * Emits when the user has moved the item into a new container.\n         */\n        this.entered = new Subject();\n        /**\n         * Emits when the user removes the item its container by dragging it into another container.\n         */\n        this.exited = new Subject();\n        /**\n         * Emits when the user drops the item inside a container.\n         */\n        this.dropped = new Subject();\n        /**\n         * Emits as the user is dragging the item. Use with caution,\n         * because this event will fire for every pixel that the user has dragged.\n         */\n        this.moved = new Observable(function (observer) {\n            /** @type {?} */\n            var subscription = _this._moveEvents.subscribe(observer);\n            _this._moveEventSubscriptions++;\n            return function () {\n                subscription.unsubscribe();\n                _this._moveEventSubscriptions--;\n            };\n        });\n        /**\n         * Handler for the `mousedown`/`touchstart` events.\n         */\n        this._pointerDown = function (event) {\n            _this.beforeStarted.next();\n            // Delegate the event based on whether it started from a handle or the element itself.\n            if (_this._handles.length) {\n                /** @type {?} */\n                var targetHandle = _this._handles.find(function (handle) {\n                    /** @type {?} */\n                    var target = event.target;\n                    return !!target && (target === handle || handle.contains((/** @type {?} */ (target))));\n                });\n                if (targetHandle && !_this._disabledHandles.has(targetHandle) && !_this.disabled) {\n                    _this._initializeDragSequence(targetHandle, event);\n                }\n            }\n            else if (!_this.disabled) {\n                _this._initializeDragSequence(_this._rootElement, event);\n            }\n        };\n        /**\n         * Handler that is invoked when the user moves their pointer after they've initiated a drag.\n         */\n        this._pointerMove = function (event) {\n            if (!_this._hasStartedDragging) {\n                /** @type {?} */\n                var pointerPosition = _this._getPointerPositionOnPage(event);\n                /** @type {?} */\n                var distanceX = Math.abs(pointerPosition.x - _this._pickupPositionOnPage.x);\n                /** @type {?} */\n                var distanceY = Math.abs(pointerPosition.y - _this._pickupPositionOnPage.y);\n                // Only start dragging after the user has moved more than the minimum distance in either\n                // direction. Note that this is preferrable over doing something like `skip(minimumDistance)`\n                // in the `pointerMove` subscription, because we're not guaranteed to have one move event\n                // per pixel of movement (e.g. if the user moves their pointer quickly).\n                if (distanceX + distanceY >= _this._config.dragStartThreshold) {\n                    _this._hasStartedDragging = true;\n                    _this._ngZone.run(function () { return _this._startDragSequence(event); });\n                }\n                return;\n            }\n            // We only need the preview dimensions if we have a boundary element.\n            if (_this._boundaryElement) {\n                // Cache the preview element rect if we haven't cached it already or if\n                // we cached it too early before the element dimensions were computed.\n                if (!_this._previewRect || (!_this._previewRect.width && !_this._previewRect.height)) {\n                    _this._previewRect = (_this._preview || _this._rootElement).getBoundingClientRect();\n                }\n            }\n            /** @type {?} */\n            var constrainedPointerPosition = _this._getConstrainedPointerPosition(event);\n            _this._hasMoved = true;\n            event.preventDefault();\n            _this._updatePointerDirectionDelta(constrainedPointerPosition);\n            if (_this._dropContainer) {\n                _this._updateActiveDropContainer(constrainedPointerPosition);\n            }\n            else {\n                /** @type {?} */\n                var activeTransform = _this._activeTransform;\n                activeTransform.x =\n                    constrainedPointerPosition.x - _this._pickupPositionOnPage.x + _this._passiveTransform.x;\n                activeTransform.y =\n                    constrainedPointerPosition.y - _this._pickupPositionOnPage.y + _this._passiveTransform.y;\n                /** @type {?} */\n                var transform = getTransform(activeTransform.x, activeTransform.y);\n                // Preserve the previous `transform` value, if there was one. Note that we apply our own\n                // transform before the user's, because things like rotation can affect which direction\n                // the element will be translated towards.\n                _this._rootElement.style.transform = _this._initialTransform ?\n                    transform + ' ' + _this._initialTransform : transform;\n                // Apply transform as attribute if dragging and svg element to work for IE\n                if (typeof SVGElement !== 'undefined' && _this._rootElement instanceof SVGElement) {\n                    /** @type {?} */\n                    var appliedTransform = \"translate(\" + activeTransform.x + \" \" + activeTransform.y + \")\";\n                    _this._rootElement.setAttribute('transform', appliedTransform);\n                }\n            }\n            // Since this event gets fired for every pixel while dragging, we only\n            // want to fire it if the consumer opted into it. Also we have to\n            // re-enter the zone because we run all of the events on the outside.\n            if (_this._moveEventSubscriptions > 0) {\n                _this._ngZone.run(function () {\n                    _this._moveEvents.next({\n                        source: _this,\n                        pointerPosition: constrainedPointerPosition,\n                        event: event,\n                        delta: _this._pointerDirectionDelta\n                    });\n                });\n            }\n        };\n        /**\n         * Handler that is invoked when the user lifts their pointer up, after initiating a drag.\n         */\n        this._pointerUp = function (event) {\n            // Note that here we use `isDragging` from the service, rather than from `this`.\n            // The difference is that the one from the service reflects whether a dragging sequence\n            // has been initiated, whereas the one on `this` includes whether the user has passed\n            // the minimum dragging threshold.\n            if (!_this._dragDropRegistry.isDragging(_this)) {\n                return;\n            }\n            _this._removeSubscriptions();\n            _this._dragDropRegistry.stopDragging(_this);\n            if (_this._handles) {\n                _this._rootElement.style.webkitTapHighlightColor = _this._rootElementTapHighlight;\n            }\n            if (!_this._hasStartedDragging) {\n                return;\n            }\n            _this.released.next({ source: _this });\n            if (!_this._dropContainer) {\n                // Convert the active transform into a passive one. This means that next time\n                // the user starts dragging the item, its position will be calculated relatively\n                // to the new passive transform.\n                _this._passiveTransform.x = _this._activeTransform.x;\n                _this._passiveTransform.y = _this._activeTransform.y;\n                _this._ngZone.run(function () { return _this.ended.next({ source: _this }); });\n                _this._dragDropRegistry.stopDragging(_this);\n                return;\n            }\n            _this._animatePreviewToPlaceholder().then(function () {\n                _this._cleanupDragArtifacts(event);\n                _this._dragDropRegistry.stopDragging(_this);\n            });\n        };\n        this.withRootElement(element);\n        _dragDropRegistry.registerDragItem(this);\n    }\n    Object.defineProperty(DragRef.prototype, \"disabled\", {\n        /** Whether starting to drag this element is disabled. */\n        get: /**\n         * Whether starting to drag this element is disabled.\n         * @return {?}\n         */\n        function () {\n            return this._disabled || !!(this._dropContainer && this._dropContainer.disabled);\n        },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */\n        function (value) {\n            /** @type {?} */\n            var newValue = coerceBooleanProperty(value);\n            if (newValue !== this._disabled) {\n                this._disabled = newValue;\n                this._toggleNativeDragInteractions();\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Returns the element that is being used as a placeholder\n     * while the current element is being dragged.\n     */\n    /**\n     * Returns the element that is being used as a placeholder\n     * while the current element is being dragged.\n     * @return {?}\n     */\n    DragRef.prototype.getPlaceholderElement = /**\n     * Returns the element that is being used as a placeholder\n     * while the current element is being dragged.\n     * @return {?}\n     */\n    function () {\n        return this._placeholder;\n    };\n    /** Returns the root draggable element. */\n    /**\n     * Returns the root draggable element.\n     * @return {?}\n     */\n    DragRef.prototype.getRootElement = /**\n     * Returns the root draggable element.\n     * @return {?}\n     */\n    function () {\n        return this._rootElement;\n    };\n    /** Registers the handles that can be used to drag the element. */\n    /**\n     * Registers the handles that can be used to drag the element.\n     * @template THIS\n     * @this {THIS}\n     * @param {?} handles\n     * @return {THIS}\n     */\n    DragRef.prototype.withHandles = /**\n     * Registers the handles that can be used to drag the element.\n     * @template THIS\n     * @this {THIS}\n     * @param {?} handles\n     * @return {THIS}\n     */\n    function (handles) {\n        (/** @type {?} */ (this))._handles = handles.map(function (handle) { return coerceElement(handle); });\n        (/** @type {?} */ (this))._handles.forEach(function (handle) { return toggleNativeDragInteractions(handle, false); });\n        (/** @type {?} */ (this))._toggleNativeDragInteractions();\n        return (/** @type {?} */ (this));\n    };\n    /**\n     * Registers the template that should be used for the drag preview.\n     * @param template Template that from which to stamp out the preview.\n     */\n    /**\n     * Registers the template that should be used for the drag preview.\n     * @template THIS\n     * @this {THIS}\n     * @param {?} template Template that from which to stamp out the preview.\n     * @return {THIS}\n     */\n    DragRef.prototype.withPreviewTemplate = /**\n     * Registers the template that should be used for the drag preview.\n     * @template THIS\n     * @this {THIS}\n     * @param {?} template Template that from which to stamp out the preview.\n     * @return {THIS}\n     */\n    function (template) {\n        (/** @type {?} */ (this))._previewTemplate = template;\n        return (/** @type {?} */ (this));\n    };\n    /**\n     * Registers the template that should be used for the drag placeholder.\n     * @param template Template that from which to stamp out the placeholder.\n     */\n    /**\n     * Registers the template that should be used for the drag placeholder.\n     * @template THIS\n     * @this {THIS}\n     * @param {?} template Template that from which to stamp out the placeholder.\n     * @return {THIS}\n     */\n    DragRef.prototype.withPlaceholderTemplate = /**\n     * Registers the template that should be used for the drag placeholder.\n     * @template THIS\n     * @this {THIS}\n     * @param {?} template Template that from which to stamp out the placeholder.\n     * @return {THIS}\n     */\n    function (template) {\n        (/** @type {?} */ (this))._placeholderTemplate = template;\n        return (/** @type {?} */ (this));\n    };\n    /**\n     * Sets an alternate drag root element. The root element is the element that will be moved as\n     * the user is dragging. Passing an alternate root element is useful when trying to enable\n     * dragging on an element that you might not have access to.\n     */\n    /**\n     * Sets an alternate drag root element. The root element is the element that will be moved as\n     * the user is dragging. Passing an alternate root element is useful when trying to enable\n     * dragging on an element that you might not have access to.\n     * @template THIS\n     * @this {THIS}\n     * @param {?} rootElement\n     * @return {THIS}\n     */\n    DragRef.prototype.withRootElement = /**\n     * Sets an alternate drag root element. The root element is the element that will be moved as\n     * the user is dragging. Passing an alternate root element is useful when trying to enable\n     * dragging on an element that you might not have access to.\n     * @template THIS\n     * @this {THIS}\n     * @param {?} rootElement\n     * @return {THIS}\n     */\n    function (rootElement) {\n        /** @type {?} */\n        var element = coerceElement(rootElement);\n        if (element !== (/** @type {?} */ (this))._rootElement) {\n            if ((/** @type {?} */ (this))._rootElement) {\n                (/** @type {?} */ (this))._removeRootElementListeners((/** @type {?} */ (this))._rootElement);\n            }\n            element.addEventListener('mousedown', (/** @type {?} */ (this))._pointerDown, activeEventListenerOptions);\n            element.addEventListener('touchstart', (/** @type {?} */ (this))._pointerDown, passiveEventListenerOptions);\n            (/** @type {?} */ (this))._initialTransform = undefined;\n            (/** @type {?} */ (this))._rootElement = element;\n        }\n        return (/** @type {?} */ (this));\n    };\n    /**\n     * Element to which the draggable's position will be constrained.\n     */\n    /**\n     * Element to which the draggable's position will be constrained.\n     * @template THIS\n     * @this {THIS}\n     * @param {?} boundaryElement\n     * @return {THIS}\n     */\n    DragRef.prototype.withBoundaryElement = /**\n     * Element to which the draggable's position will be constrained.\n     * @template THIS\n     * @this {THIS}\n     * @param {?} boundaryElement\n     * @return {THIS}\n     */\n    function (boundaryElement) {\n        (/** @type {?} */ (this))._boundaryElement = boundaryElement ? coerceElement(boundaryElement) : null;\n        return (/** @type {?} */ (this));\n    };\n    /** Removes the dragging functionality from the DOM element. */\n    /**\n     * Removes the dragging functionality from the DOM element.\n     * @return {?}\n     */\n    DragRef.prototype.dispose = /**\n     * Removes the dragging functionality from the DOM element.\n     * @return {?}\n     */\n    function () {\n        this._removeRootElementListeners(this._rootElement);\n        // Do this check before removing from the registry since it'll\n        // stop being considered as dragged once it is removed.\n        if (this.isDragging()) {\n            // Since we move out the element to the end of the body while it's being\n            // dragged, we have to make sure that it's removed if it gets destroyed.\n            removeElement(this._rootElement);\n        }\n        this._destroyPreview();\n        this._destroyPlaceholder();\n        this._dragDropRegistry.removeDragItem(this);\n        this._removeSubscriptions();\n        this.beforeStarted.complete();\n        this.started.complete();\n        this.released.complete();\n        this.ended.complete();\n        this.entered.complete();\n        this.exited.complete();\n        this.dropped.complete();\n        this._moveEvents.complete();\n        this._handles = [];\n        this._disabledHandles.clear();\n        this._dropContainer = undefined;\n        this._boundaryElement = this._rootElement = this._placeholderTemplate =\n            this._previewTemplate = this._nextSibling = (/** @type {?} */ (null));\n    };\n    /** Checks whether the element is currently being dragged. */\n    /**\n     * Checks whether the element is currently being dragged.\n     * @return {?}\n     */\n    DragRef.prototype.isDragging = /**\n     * Checks whether the element is currently being dragged.\n     * @return {?}\n     */\n    function () {\n        return this._hasStartedDragging && this._dragDropRegistry.isDragging(this);\n    };\n    /** Resets a standalone drag item to its initial position. */\n    /**\n     * Resets a standalone drag item to its initial position.\n     * @return {?}\n     */\n    DragRef.prototype.reset = /**\n     * Resets a standalone drag item to its initial position.\n     * @return {?}\n     */\n    function () {\n        this._rootElement.style.transform = this._initialTransform || '';\n        this._activeTransform = { x: 0, y: 0 };\n        this._passiveTransform = { x: 0, y: 0 };\n    };\n    /**\n     * Sets a handle as disabled. While a handle is disabled, it'll capture and interrupt dragging.\n     * @param handle Handle element that should be disabled.\n     */\n    /**\n     * Sets a handle as disabled. While a handle is disabled, it'll capture and interrupt dragging.\n     * @param {?} handle Handle element that should be disabled.\n     * @return {?}\n     */\n    DragRef.prototype.disableHandle = /**\n     * Sets a handle as disabled. While a handle is disabled, it'll capture and interrupt dragging.\n     * @param {?} handle Handle element that should be disabled.\n     * @return {?}\n     */\n    function (handle) {\n        if (this._handles.indexOf(handle) > -1) {\n            this._disabledHandles.add(handle);\n        }\n    };\n    /**\n     * Enables a handle, if it has been disabled.\n     * @param handle Handle element to be enabled.\n     */\n    /**\n     * Enables a handle, if it has been disabled.\n     * @param {?} handle Handle element to be enabled.\n     * @return {?}\n     */\n    DragRef.prototype.enableHandle = /**\n     * Enables a handle, if it has been disabled.\n     * @param {?} handle Handle element to be enabled.\n     * @return {?}\n     */\n    function (handle) {\n        this._disabledHandles.delete(handle);\n    };\n    /** Sets the layout direction of the draggable item. */\n    /**\n     * Sets the layout direction of the draggable item.\n     * @template THIS\n     * @this {THIS}\n     * @param {?} direction\n     * @return {THIS}\n     */\n    DragRef.prototype.withDirection = /**\n     * Sets the layout direction of the draggable item.\n     * @template THIS\n     * @this {THIS}\n     * @param {?} direction\n     * @return {THIS}\n     */\n    function (direction) {\n        (/** @type {?} */ (this))._direction = direction;\n        return (/** @type {?} */ (this));\n    };\n    /** Sets the container that the item is part of. */\n    /**\n     * Sets the container that the item is part of.\n     * @param {?} container\n     * @return {?}\n     */\n    DragRef.prototype._withDropContainer = /**\n     * Sets the container that the item is part of.\n     * @param {?} container\n     * @return {?}\n     */\n    function (container) {\n        this._dropContainer = container;\n    };\n    /** Unsubscribes from the global subscriptions. */\n    /**\n     * Unsubscribes from the global subscriptions.\n     * @private\n     * @return {?}\n     */\n    DragRef.prototype._removeSubscriptions = /**\n     * Unsubscribes from the global subscriptions.\n     * @private\n     * @return {?}\n     */\n    function () {\n        this._pointerMoveSubscription.unsubscribe();\n        this._pointerUpSubscription.unsubscribe();\n    };\n    /** Destroys the preview element and its ViewRef. */\n    /**\n     * Destroys the preview element and its ViewRef.\n     * @private\n     * @return {?}\n     */\n    DragRef.prototype._destroyPreview = /**\n     * Destroys the preview element and its ViewRef.\n     * @private\n     * @return {?}\n     */\n    function () {\n        if (this._preview) {\n            removeElement(this._preview);\n        }\n        if (this._previewRef) {\n            this._previewRef.destroy();\n        }\n        this._preview = this._previewRef = (/** @type {?} */ (null));\n    };\n    /** Destroys the placeholder element and its ViewRef. */\n    /**\n     * Destroys the placeholder element and its ViewRef.\n     * @private\n     * @return {?}\n     */\n    DragRef.prototype._destroyPlaceholder = /**\n     * Destroys the placeholder element and its ViewRef.\n     * @private\n     * @return {?}\n     */\n    function () {\n        if (this._placeholder) {\n            removeElement(this._placeholder);\n        }\n        if (this._placeholderRef) {\n            this._placeholderRef.destroy();\n        }\n        this._placeholder = this._placeholderRef = (/** @type {?} */ (null));\n    };\n    /** Starts the dragging sequence. */\n    /**\n     * Starts the dragging sequence.\n     * @private\n     * @param {?} event\n     * @return {?}\n     */\n    DragRef.prototype._startDragSequence = /**\n     * Starts the dragging sequence.\n     * @private\n     * @param {?} event\n     * @return {?}\n     */\n    function (event) {\n        // Emit the event on the item before the one on the container.\n        this.started.next({ source: this });\n        if (isTouchEvent(event)) {\n            this._lastTouchEventTime = Date.now();\n        }\n        if (this._dropContainer) {\n            /** @type {?} */\n            var element = this._rootElement;\n            // Grab the `nextSibling` before the preview and placeholder\n            // have been created so we don't get the preview by accident.\n            this._nextSibling = element.nextSibling;\n            /** @type {?} */\n            var preview = this._preview = this._createPreviewElement();\n            /** @type {?} */\n            var placeholder = this._placeholder = this._createPlaceholderElement();\n            // We move the element out at the end of the body and we make it hidden, because keeping it in\n            // place will throw off the consumer's `:last-child` selectors. We can't remove the element\n            // from the DOM completely, because iOS will stop firing all subsequent events in the chain.\n            element.style.display = 'none';\n            this._document.body.appendChild((/** @type {?} */ (element.parentNode)).replaceChild(placeholder, element));\n            this._document.body.appendChild(preview);\n            this._dropContainer.start();\n        }\n    };\n    /**\n     * Sets up the different variables and subscriptions\n     * that will be necessary for the dragging sequence.\n     * @param referenceElement Element that started the drag sequence.\n     * @param event Browser event object that started the sequence.\n     */\n    /**\n     * Sets up the different variables and subscriptions\n     * that will be necessary for the dragging sequence.\n     * @private\n     * @param {?} referenceElement Element that started the drag sequence.\n     * @param {?} event Browser event object that started the sequence.\n     * @return {?}\n     */\n    DragRef.prototype._initializeDragSequence = /**\n     * Sets up the different variables and subscriptions\n     * that will be necessary for the dragging sequence.\n     * @private\n     * @param {?} referenceElement Element that started the drag sequence.\n     * @param {?} event Browser event object that started the sequence.\n     * @return {?}\n     */\n    function (referenceElement, event) {\n        // Always stop propagation for the event that initializes\n        // the dragging sequence, in order to prevent it from potentially\n        // starting another sequence for a draggable parent somewhere up the DOM tree.\n        event.stopPropagation();\n        /** @type {?} */\n        var isDragging = this.isDragging();\n        /** @type {?} */\n        var isTouchSequence = isTouchEvent(event);\n        /** @type {?} */\n        var isAuxiliaryMouseButton = !isTouchSequence && ((/** @type {?} */ (event))).button !== 0;\n        /** @type {?} */\n        var rootElement = this._rootElement;\n        /** @type {?} */\n        var isSyntheticEvent = !isTouchSequence && this._lastTouchEventTime &&\n            this._lastTouchEventTime + MOUSE_EVENT_IGNORE_TIME > Date.now();\n        // If the event started from an element with the native HTML drag&drop, it'll interfere\n        // with our own dragging (e.g. `img` tags do it by default). Prevent the default action\n        // to stop it from happening. Note that preventing on `dragstart` also seems to work, but\n        // it's flaky and it fails if the user drags it away quickly. Also note that we only want\n        // to do this for `mousedown` since doing the same for `touchstart` will stop any `click`\n        // events from firing on touch devices.\n        if (event.target && ((/** @type {?} */ (event.target))).draggable && event.type === 'mousedown') {\n            event.preventDefault();\n        }\n        // Abort if the user is already dragging or is using a mouse button other than the primary one.\n        if (isDragging || isAuxiliaryMouseButton || isSyntheticEvent) {\n            return;\n        }\n        // Cache the previous transform amount only after the first drag sequence, because\n        // we don't want our own transforms to stack on top of each other.\n        if (this._initialTransform == null) {\n            this._initialTransform = this._rootElement.style.transform || '';\n        }\n        // If we've got handles, we need to disable the tap highlight on the entire root element,\n        // otherwise iOS will still add it, even though all the drag interactions on the handle\n        // are disabled.\n        if (this._handles.length) {\n            this._rootElementTapHighlight = rootElement.style.webkitTapHighlightColor;\n            rootElement.style.webkitTapHighlightColor = 'transparent';\n        }\n        this._toggleNativeDragInteractions();\n        this._hasStartedDragging = this._hasMoved = false;\n        this._initialContainer = (/** @type {?} */ (this._dropContainer));\n        this._pointerMoveSubscription = this._dragDropRegistry.pointerMove.subscribe(this._pointerMove);\n        this._pointerUpSubscription = this._dragDropRegistry.pointerUp.subscribe(this._pointerUp);\n        this._scrollPosition = this._viewportRuler.getViewportScrollPosition();\n        if (this._boundaryElement) {\n            this._boundaryRect = this._boundaryElement.getBoundingClientRect();\n        }\n        // If we have a custom preview template, the element won't be visible anyway so we avoid the\n        // extra `getBoundingClientRect` calls and just move the preview next to the cursor.\n        this._pickupPositionInElement = this._previewTemplate && this._previewTemplate.template ?\n            { x: 0, y: 0 } :\n            this._getPointerPositionInElement(referenceElement, event);\n        /** @type {?} */\n        var pointerPosition = this._pickupPositionOnPage = this._getPointerPositionOnPage(event);\n        this._pointerDirectionDelta = { x: 0, y: 0 };\n        this._pointerPositionAtLastDirectionChange = { x: pointerPosition.x, y: pointerPosition.y };\n        this._dragDropRegistry.startDragging(this, event);\n    };\n    /** Cleans up the DOM artifacts that were added to facilitate the element being dragged. */\n    /**\n     * Cleans up the DOM artifacts that were added to facilitate the element being dragged.\n     * @private\n     * @param {?} event\n     * @return {?}\n     */\n    DragRef.prototype._cleanupDragArtifacts = /**\n     * Cleans up the DOM artifacts that were added to facilitate the element being dragged.\n     * @private\n     * @param {?} event\n     * @return {?}\n     */\n    function (event) {\n        var _this = this;\n        // Restore the element's visibility and insert it at its old position in the DOM.\n        // It's important that we maintain the position, because moving the element around in the DOM\n        // can throw off `NgFor` which does smart diffing and re-creates elements only when necessary,\n        // while moving the existing elements in all other cases.\n        this._rootElement.style.display = '';\n        if (this._nextSibling) {\n            (/** @type {?} */ (this._nextSibling.parentNode)).insertBefore(this._rootElement, this._nextSibling);\n        }\n        else {\n            this._initialContainer.element.appendChild(this._rootElement);\n        }\n        this._destroyPreview();\n        this._destroyPlaceholder();\n        this._boundaryRect = this._previewRect = undefined;\n        // Re-enter the NgZone since we bound `document` events on the outside.\n        this._ngZone.run(function () {\n            /** @type {?} */\n            var container = (/** @type {?} */ (_this._dropContainer));\n            /** @type {?} */\n            var currentIndex = container.getItemIndex(_this);\n            var _a = _this._getPointerPositionOnPage(event), x = _a.x, y = _a.y;\n            /** @type {?} */\n            var isPointerOverContainer = container._isOverContainer(x, y);\n            _this.ended.next({ source: _this });\n            _this.dropped.next({\n                item: _this,\n                currentIndex: currentIndex,\n                previousIndex: _this._initialContainer.getItemIndex(_this),\n                container: container,\n                previousContainer: _this._initialContainer,\n                isPointerOverContainer: isPointerOverContainer\n            });\n            container.drop(_this, currentIndex, _this._initialContainer, isPointerOverContainer);\n            _this._dropContainer = _this._initialContainer;\n        });\n    };\n    /**\n     * Updates the item's position in its drop container, or moves it\n     * into a new one, depending on its current drag position.\n     */\n    /**\n     * Updates the item's position in its drop container, or moves it\n     * into a new one, depending on its current drag position.\n     * @private\n     * @param {?} __0\n     * @return {?}\n     */\n    DragRef.prototype._updateActiveDropContainer = /**\n     * Updates the item's position in its drop container, or moves it\n     * into a new one, depending on its current drag position.\n     * @private\n     * @param {?} __0\n     * @return {?}\n     */\n    function (_a) {\n        var _this = this;\n        var x = _a.x, y = _a.y;\n        // Drop container that draggable has been moved into.\n        /** @type {?} */\n        var newContainer = (/** @type {?} */ (this._dropContainer))._getSiblingContainerFromPosition(this, x, y) ||\n            this._initialContainer._getSiblingContainerFromPosition(this, x, y);\n        // If we couldn't find a new container to move the item into, and the item has left it's\n        // initial container, check whether the it's over the initial container. This handles the\n        // case where two containers are connected one way and the user tries to undo dragging an\n        // item into a new container.\n        if (!newContainer && this._dropContainer !== this._initialContainer &&\n            this._initialContainer._isOverContainer(x, y)) {\n            newContainer = this._initialContainer;\n        }\n        if (newContainer && newContainer !== this._dropContainer) {\n            this._ngZone.run(function () {\n                // Notify the old container that the item has left.\n                _this.exited.next({ item: _this, container: (/** @type {?} */ (_this._dropContainer)) });\n                (/** @type {?} */ (_this._dropContainer)).exit(_this);\n                // Notify the new container that the item has entered.\n                _this.entered.next({ item: _this, container: (/** @type {?} */ (newContainer)) });\n                _this._dropContainer = (/** @type {?} */ (newContainer));\n                _this._dropContainer.enter(_this, x, y);\n            });\n        }\n        (/** @type {?} */ (this._dropContainer))._sortItem(this, x, y, this._pointerDirectionDelta);\n        this._preview.style.transform =\n            getTransform(x - this._pickupPositionInElement.x, y - this._pickupPositionInElement.y);\n    };\n    /**\n     * Creates the element that will be rendered next to the user's pointer\n     * and will be used as a preview of the element that is being dragged.\n     */\n    /**\n     * Creates the element that will be rendered next to the user's pointer\n     * and will be used as a preview of the element that is being dragged.\n     * @private\n     * @return {?}\n     */\n    DragRef.prototype._createPreviewElement = /**\n     * Creates the element that will be rendered next to the user's pointer\n     * and will be used as a preview of the element that is being dragged.\n     * @private\n     * @return {?}\n     */\n    function () {\n        /** @type {?} */\n        var previewConfig = this._previewTemplate;\n        /** @type {?} */\n        var previewTemplate = previewConfig ? previewConfig.template : null;\n        /** @type {?} */\n        var preview;\n        if (previewTemplate) {\n            /** @type {?} */\n            var viewRef = (/** @type {?} */ (previewConfig)).viewContainer.createEmbeddedView(previewTemplate, (/** @type {?} */ (previewConfig)).context);\n            preview = viewRef.rootNodes[0];\n            this._previewRef = viewRef;\n            preview.style.transform =\n                getTransform(this._pickupPositionOnPage.x, this._pickupPositionOnPage.y);\n        }\n        else {\n            /** @type {?} */\n            var element = this._rootElement;\n            /** @type {?} */\n            var elementRect = element.getBoundingClientRect();\n            preview = deepCloneNode(element);\n            preview.style.width = elementRect.width + \"px\";\n            preview.style.height = elementRect.height + \"px\";\n            preview.style.transform = getTransform(elementRect.left, elementRect.top);\n        }\n        extendStyles(preview.style, {\n            // It's important that we disable the pointer events on the preview, because\n            // it can throw off the `document.elementFromPoint` calls in the `CdkDropList`.\n            pointerEvents: 'none',\n            position: 'fixed',\n            top: '0',\n            left: '0',\n            zIndex: '1000'\n        });\n        toggleNativeDragInteractions(preview, false);\n        preview.classList.add('cdk-drag-preview');\n        preview.setAttribute('dir', this._direction);\n        return preview;\n    };\n    /**\n     * Animates the preview element from its current position to the location of the drop placeholder.\n     * @returns Promise that resolves when the animation completes.\n     */\n    /**\n     * Animates the preview element from its current position to the location of the drop placeholder.\n     * @private\n     * @return {?} Promise that resolves when the animation completes.\n     */\n    DragRef.prototype._animatePreviewToPlaceholder = /**\n     * Animates the preview element from its current position to the location of the drop placeholder.\n     * @private\n     * @return {?} Promise that resolves when the animation completes.\n     */\n    function () {\n        var _this = this;\n        // If the user hasn't moved yet, the transitionend event won't fire.\n        if (!this._hasMoved) {\n            return Promise.resolve();\n        }\n        /** @type {?} */\n        var placeholderRect = this._placeholder.getBoundingClientRect();\n        // Apply the class that adds a transition to the preview.\n        this._preview.classList.add('cdk-drag-animating');\n        // Move the preview to the placeholder position.\n        this._preview.style.transform = getTransform(placeholderRect.left, placeholderRect.top);\n        // If the element doesn't have a `transition`, the `transitionend` event won't fire. Since\n        // we need to trigger a style recalculation in order for the `cdk-drag-animating` class to\n        // apply its style, we take advantage of the available info to figure out whether we need to\n        // bind the event in the first place.\n        /** @type {?} */\n        var duration = getTransformTransitionDurationInMs(this._preview);\n        if (duration === 0) {\n            return Promise.resolve();\n        }\n        return this._ngZone.runOutsideAngular(function () {\n            return new Promise(function (resolve) {\n                /** @type {?} */\n                var handler = (/** @type {?} */ ((function (event) {\n                    if (!event || (event.target === _this._preview && event.propertyName === 'transform')) {\n                        _this._preview.removeEventListener('transitionend', handler);\n                        resolve();\n                        clearTimeout(timeout);\n                    }\n                })));\n                // If a transition is short enough, the browser might not fire the `transitionend` event.\n                // Since we know how long it's supposed to take, add a timeout with a 50% buffer that'll\n                // fire if the transition hasn't completed when it was supposed to.\n                /** @type {?} */\n                var timeout = setTimeout((/** @type {?} */ (handler)), duration * 1.5);\n                _this._preview.addEventListener('transitionend', handler);\n            });\n        });\n    };\n    /** Creates an element that will be shown instead of the current element while dragging. */\n    /**\n     * Creates an element that will be shown instead of the current element while dragging.\n     * @private\n     * @return {?}\n     */\n    DragRef.prototype._createPlaceholderElement = /**\n     * Creates an element that will be shown instead of the current element while dragging.\n     * @private\n     * @return {?}\n     */\n    function () {\n        /** @type {?} */\n        var placeholderConfig = this._placeholderTemplate;\n        /** @type {?} */\n        var placeholderTemplate = placeholderConfig ? placeholderConfig.template : null;\n        /** @type {?} */\n        var placeholder;\n        if (placeholderTemplate) {\n            this._placeholderRef = (/** @type {?} */ (placeholderConfig)).viewContainer.createEmbeddedView(placeholderTemplate, (/** @type {?} */ (placeholderConfig)).context);\n            placeholder = this._placeholderRef.rootNodes[0];\n        }\n        else {\n            placeholder = deepCloneNode(this._rootElement);\n        }\n        placeholder.classList.add('cdk-drag-placeholder');\n        return placeholder;\n    };\n    /**\n     * Figures out the coordinates at which an element was picked up.\n     * @param referenceElement Element that initiated the dragging.\n     * @param event Event that initiated the dragging.\n     */\n    /**\n     * Figures out the coordinates at which an element was picked up.\n     * @private\n     * @param {?} referenceElement Element that initiated the dragging.\n     * @param {?} event Event that initiated the dragging.\n     * @return {?}\n     */\n    DragRef.prototype._getPointerPositionInElement = /**\n     * Figures out the coordinates at which an element was picked up.\n     * @private\n     * @param {?} referenceElement Element that initiated the dragging.\n     * @param {?} event Event that initiated the dragging.\n     * @return {?}\n     */\n    function (referenceElement, event) {\n        /** @type {?} */\n        var elementRect = this._rootElement.getBoundingClientRect();\n        /** @type {?} */\n        var handleElement = referenceElement === this._rootElement ? null : referenceElement;\n        /** @type {?} */\n        var referenceRect = handleElement ? handleElement.getBoundingClientRect() : elementRect;\n        /** @type {?} */\n        var point = isTouchEvent(event) ? event.targetTouches[0] : event;\n        /** @type {?} */\n        var x = point.pageX - referenceRect.left - this._scrollPosition.left;\n        /** @type {?} */\n        var y = point.pageY - referenceRect.top - this._scrollPosition.top;\n        return {\n            x: referenceRect.left - elementRect.left + x,\n            y: referenceRect.top - elementRect.top + y\n        };\n    };\n    /** Determines the point of the page that was touched by the user. */\n    /**\n     * Determines the point of the page that was touched by the user.\n     * @private\n     * @param {?} event\n     * @return {?}\n     */\n    DragRef.prototype._getPointerPositionOnPage = /**\n     * Determines the point of the page that was touched by the user.\n     * @private\n     * @param {?} event\n     * @return {?}\n     */\n    function (event) {\n        // `touches` will be empty for start/end events so we have to fall back to `changedTouches`.\n        /** @type {?} */\n        var point = isTouchEvent(event) ? (event.touches[0] || event.changedTouches[0]) : event;\n        return {\n            x: point.pageX - this._scrollPosition.left,\n            y: point.pageY - this._scrollPosition.top\n        };\n    };\n    /** Gets the pointer position on the page, accounting for any position constraints. */\n    /**\n     * Gets the pointer position on the page, accounting for any position constraints.\n     * @private\n     * @param {?} event\n     * @return {?}\n     */\n    DragRef.prototype._getConstrainedPointerPosition = /**\n     * Gets the pointer position on the page, accounting for any position constraints.\n     * @private\n     * @param {?} event\n     * @return {?}\n     */\n    function (event) {\n        /** @type {?} */\n        var point = this._getPointerPositionOnPage(event);\n        /** @type {?} */\n        var dropContainerLock = this._dropContainer ? this._dropContainer.lockAxis : null;\n        if (this.lockAxis === 'x' || dropContainerLock === 'x') {\n            point.y = this._pickupPositionOnPage.y;\n        }\n        else if (this.lockAxis === 'y' || dropContainerLock === 'y') {\n            point.x = this._pickupPositionOnPage.x;\n        }\n        if (this._boundaryRect) {\n            var _a = this._pickupPositionInElement, pickupX = _a.x, pickupY = _a.y;\n            /** @type {?} */\n            var boundaryRect = this._boundaryRect;\n            /** @type {?} */\n            var previewRect = (/** @type {?} */ (this._previewRect));\n            /** @type {?} */\n            var minY = boundaryRect.top + pickupY;\n            /** @type {?} */\n            var maxY = boundaryRect.bottom - (previewRect.height - pickupY);\n            /** @type {?} */\n            var minX = boundaryRect.left + pickupX;\n            /** @type {?} */\n            var maxX = boundaryRect.right - (previewRect.width - pickupX);\n            point.x = clamp(point.x, minX, maxX);\n            point.y = clamp(point.y, minY, maxY);\n        }\n        return point;\n    };\n    /** Updates the current drag delta, based on the user's current pointer position on the page. */\n    /**\n     * Updates the current drag delta, based on the user's current pointer position on the page.\n     * @private\n     * @param {?} pointerPositionOnPage\n     * @return {?}\n     */\n    DragRef.prototype._updatePointerDirectionDelta = /**\n     * Updates the current drag delta, based on the user's current pointer position on the page.\n     * @private\n     * @param {?} pointerPositionOnPage\n     * @return {?}\n     */\n    function (pointerPositionOnPage) {\n        var x = pointerPositionOnPage.x, y = pointerPositionOnPage.y;\n        /** @type {?} */\n        var delta = this._pointerDirectionDelta;\n        /** @type {?} */\n        var positionSinceLastChange = this._pointerPositionAtLastDirectionChange;\n        // Amount of pixels the user has dragged since the last time the direction changed.\n        /** @type {?} */\n        var changeX = Math.abs(x - positionSinceLastChange.x);\n        /** @type {?} */\n        var changeY = Math.abs(y - positionSinceLastChange.y);\n        // Because we handle pointer events on a per-pixel basis, we don't want the delta\n        // to change for every pixel, otherwise anything that depends on it can look erratic.\n        // To make the delta more consistent, we track how much the user has moved since the last\n        // delta change and we only update it after it has reached a certain threshold.\n        if (changeX > this._config.pointerDirectionChangeThreshold) {\n            delta.x = x > positionSinceLastChange.x ? 1 : -1;\n            positionSinceLastChange.x = x;\n        }\n        if (changeY > this._config.pointerDirectionChangeThreshold) {\n            delta.y = y > positionSinceLastChange.y ? 1 : -1;\n            positionSinceLastChange.y = y;\n        }\n        return delta;\n    };\n    /** Toggles the native drag interactions, based on how many handles are registered. */\n    /**\n     * Toggles the native drag interactions, based on how many handles are registered.\n     * @private\n     * @return {?}\n     */\n    DragRef.prototype._toggleNativeDragInteractions = /**\n     * Toggles the native drag interactions, based on how many handles are registered.\n     * @private\n     * @return {?}\n     */\n    function () {\n        if (!this._rootElement || !this._handles) {\n            return;\n        }\n        /** @type {?} */\n        var shouldEnable = this.disabled || this._handles.length > 0;\n        if (shouldEnable !== this._nativeInteractionsEnabled) {\n            this._nativeInteractionsEnabled = shouldEnable;\n            toggleNativeDragInteractions(this._rootElement, shouldEnable);\n        }\n    };\n    /** Removes the manually-added event listeners from the root element. */\n    /**\n     * Removes the manually-added event listeners from the root element.\n     * @private\n     * @param {?} element\n     * @return {?}\n     */\n    DragRef.prototype._removeRootElementListeners = /**\n     * Removes the manually-added event listeners from the root element.\n     * @private\n     * @param {?} element\n     * @return {?}\n     */\n    function (element) {\n        element.removeEventListener('mousedown', this._pointerDown, activeEventListenerOptions);\n        element.removeEventListener('touchstart', this._pointerDown, passiveEventListenerOptions);\n    };\n    return DragRef;\n}());\n/**\n * Gets a 3d `transform` that can be applied to an element.\n * @param {?} x Desired position of the element along the X axis.\n * @param {?} y Desired position of the element along the Y axis.\n * @return {?}\n */\nfunction getTransform(x, y) {\n    // Round the transforms since some browsers will\n    // blur the elements for sub-pixel transforms.\n    return \"translate3d(\" + Math.round(x) + \"px, \" + Math.round(y) + \"px, 0)\";\n}\n/**\n * Creates a deep clone of an element.\n * @param {?} node\n * @return {?}\n */\nfunction deepCloneNode(node) {\n    /** @type {?} */\n    var clone = (/** @type {?} */ (node.cloneNode(true)));\n    // Remove the `id` to avoid having multiple elements with the same id on the page.\n    clone.removeAttribute('id');\n    return clone;\n}\n/**\n * Clamps a value between a minimum and a maximum.\n * @param {?} value\n * @param {?} min\n * @param {?} max\n * @return {?}\n */\nfunction clamp(value, min, max) {\n    return Math.max(min, Math.min(max, value));\n}\n/**\n * Helper to remove an element from the DOM and to do all the necessary null checks.\n * @param {?} element Element to be removed.\n * @return {?}\n */\nfunction removeElement(element) {\n    if (element && element.parentNode) {\n        element.parentNode.removeChild(element);\n    }\n}\n/**\n * Determines whether an event is a touch event.\n * @param {?} event\n * @return {?}\n */\nfunction isTouchEvent(event) {\n    return event.type.startsWith('touch');\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Moves an item one index in an array to another.\n * @template T\n * @param {?} array Array in which to move the item.\n * @param {?} fromIndex Starting index of the item.\n * @param {?} toIndex Index to which the item should be moved.\n * @return {?}\n */\nfunction moveItemInArray(array, fromIndex, toIndex) {\n    /** @type {?} */\n    var from = clamp$1(fromIndex, array.length - 1);\n    /** @type {?} */\n    var to = clamp$1(toIndex, array.length - 1);\n    if (from === to) {\n        return;\n    }\n    /** @type {?} */\n    var target = array[from];\n    /** @type {?} */\n    var delta = to < from ? -1 : 1;\n    for (var i = from; i !== to; i += delta) {\n        array[i] = array[i + delta];\n    }\n    array[to] = target;\n}\n/**\n * Moves an item from one array to another.\n * @template T\n * @param {?} currentArray Array from which to transfer the item.\n * @param {?} targetArray Array into which to put the item.\n * @param {?} currentIndex Index of the item in its current array.\n * @param {?} targetIndex Index at which to insert the item.\n * @return {?}\n */\nfunction transferArrayItem(currentArray, targetArray, currentIndex, targetIndex) {\n    /** @type {?} */\n    var from = clamp$1(currentIndex, currentArray.length - 1);\n    /** @type {?} */\n    var to = clamp$1(targetIndex, targetArray.length);\n    if (currentArray.length) {\n        targetArray.splice(to, 0, currentArray.splice(from, 1)[0]);\n    }\n}\n/**\n * Copies an item from one array to another, leaving it in its\n * original position in current array.\n * @template T\n * @param {?} currentArray Array from which to copy the item.\n * @param {?} targetArray Array into which is copy the item.\n * @param {?} currentIndex Index of the item in its current array.\n * @param {?} targetIndex Index at which to insert the item.\n *\n * @return {?}\n */\nfunction copyArrayItem(currentArray, targetArray, currentIndex, targetIndex) {\n    /** @type {?} */\n    var to = clamp$1(targetIndex, targetArray.length);\n    if (currentArray.length) {\n        targetArray.splice(to, 0, currentArray[currentIndex]);\n    }\n}\n/**\n * Clamps a number between zero and a maximum.\n * @param {?} value\n * @param {?} max\n * @return {?}\n */\nfunction clamp$1(value, max) {\n    return Math.max(0, Math.min(max, value));\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Counter used to generate unique ids for drop refs.\n * @type {?}\n */\nvar _uniqueIdCounter = 0;\n/**\n * Proximity, as a ratio to width/height, at which a\n * dragged item will affect the drop container.\n * @type {?}\n */\nvar DROP_PROXIMITY_THRESHOLD = 0.05;\n/**\n * Reference to a drop list. Used to manipulate or dispose of the container.\n * \\@docs-private\n * @template T\n */\nvar  /**\n * Reference to a drop list. Used to manipulate or dispose of the container.\n * \\@docs-private\n * @template T\n */\nDropListRef = /** @class */ (function () {\n    function DropListRef(element, _dragDropRegistry, _document) {\n        this._dragDropRegistry = _dragDropRegistry;\n        /**\n         * Unique ID for the drop list.\n         * @deprecated No longer being used. To be removed.\n         * \\@breaking-change 8.0.0\n         */\n        this.id = \"cdk-drop-list-ref-\" + _uniqueIdCounter++;\n        /**\n         * Whether starting a dragging sequence from this container is disabled.\n         */\n        this.disabled = false;\n        /**\n         * Function that is used to determine whether an item\n         * is allowed to be moved into a drop container.\n         */\n        this.enterPredicate = function () { return true; };\n        /**\n         * Emits right before dragging has started.\n         */\n        this.beforeStarted = new Subject();\n        /**\n         * Emits when the user has moved a new drag item into this container.\n         */\n        this.entered = new Subject();\n        /**\n         * Emits when the user removes an item from the container\n         * by dragging it into another container.\n         */\n        this.exited = new Subject();\n        /**\n         * Emits when the user drops an item inside the container.\n         */\n        this.dropped = new Subject();\n        /**\n         * Emits as the user is swapping items while actively dragging.\n         */\n        this.sorted = new Subject();\n        /**\n         * Whether an item in the list is being dragged.\n         */\n        this._isDragging = false;\n        /**\n         * Cache of the dimensions of all the items inside the container.\n         */\n        this._itemPositions = [];\n        /**\n         * Keeps track of the item that was last swapped with the dragged item, as\n         * well as what direction the pointer was moving in when the swap occured.\n         */\n        this._previousSwap = { drag: (/** @type {?} */ (null)), delta: 0 };\n        /**\n         * Drop lists that are connected to the current one.\n         */\n        this._siblings = [];\n        /**\n         * Direction in which the list is oriented.\n         */\n        this._orientation = 'vertical';\n        /**\n         * Connected siblings that currently have a dragged item.\n         */\n        this._activeSiblings = new Set();\n        /**\n         * Layout direction of the drop list.\n         */\n        this._direction = 'ltr';\n        _dragDropRegistry.registerDropContainer(this);\n        this._document = _document;\n        this.element = element instanceof ElementRef ? element.nativeElement : element;\n    }\n    /** Removes the drop list functionality from the DOM element. */\n    /**\n     * Removes the drop list functionality from the DOM element.\n     * @return {?}\n     */\n    DropListRef.prototype.dispose = /**\n     * Removes the drop list functionality from the DOM element.\n     * @return {?}\n     */\n    function () {\n        this.beforeStarted.complete();\n        this.entered.complete();\n        this.exited.complete();\n        this.dropped.complete();\n        this.sorted.complete();\n        this._activeSiblings.clear();\n        this._dragDropRegistry.removeDropContainer(this);\n    };\n    /** Whether an item from this list is currently being dragged. */\n    /**\n     * Whether an item from this list is currently being dragged.\n     * @return {?}\n     */\n    DropListRef.prototype.isDragging = /**\n     * Whether an item from this list is currently being dragged.\n     * @return {?}\n     */\n    function () {\n        return this._isDragging;\n    };\n    /** Starts dragging an item. */\n    /**\n     * Starts dragging an item.\n     * @return {?}\n     */\n    DropListRef.prototype.start = /**\n     * Starts dragging an item.\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        this.beforeStarted.next();\n        this._isDragging = true;\n        this._activeDraggables = this._draggables.slice();\n        this._cacheOwnPosition();\n        this._cacheItemPositions();\n        this._siblings.forEach(function (sibling) { return sibling._startReceiving(_this); });\n    };\n    /**\n     * Emits an event to indicate that the user moved an item into the container.\n     * @param item Item that was moved into the container.\n     * @param pointerX Position of the item along the X axis.\n     * @param pointerY Position of the item along the Y axis.\n     */\n    /**\n     * Emits an event to indicate that the user moved an item into the container.\n     * @param {?} item Item that was moved into the container.\n     * @param {?} pointerX Position of the item along the X axis.\n     * @param {?} pointerY Position of the item along the Y axis.\n     * @return {?}\n     */\n    DropListRef.prototype.enter = /**\n     * Emits an event to indicate that the user moved an item into the container.\n     * @param {?} item Item that was moved into the container.\n     * @param {?} pointerX Position of the item along the X axis.\n     * @param {?} pointerY Position of the item along the Y axis.\n     * @return {?}\n     */\n    function (item, pointerX, pointerY) {\n        this.entered.next({ item: item, container: this });\n        this.start();\n        // We use the coordinates of where the item entered the drop\n        // zone to figure out at which index it should be inserted.\n        /** @type {?} */\n        var newIndex = this._getItemIndexFromPointerPosition(item, pointerX, pointerY);\n        /** @type {?} */\n        var currentIndex = this._activeDraggables.indexOf(item);\n        /** @type {?} */\n        var newPositionReference = this._activeDraggables[newIndex];\n        /** @type {?} */\n        var placeholder = item.getPlaceholderElement();\n        // Since the item may be in the `activeDraggables` already (e.g. if the user dragged it\n        // into another container and back again), we have to ensure that it isn't duplicated.\n        if (currentIndex > -1) {\n            this._activeDraggables.splice(currentIndex, 1);\n        }\n        // Don't use items that are being dragged as a reference, because\n        // their element has been moved down to the bottom of the body.\n        if (newPositionReference && !this._dragDropRegistry.isDragging(newPositionReference)) {\n            /** @type {?} */\n            var element = newPositionReference.getRootElement();\n            (/** @type {?} */ (element.parentElement)).insertBefore(placeholder, element);\n            this._activeDraggables.splice(newIndex, 0, item);\n        }\n        else {\n            this.element.appendChild(placeholder);\n            this._activeDraggables.push(item);\n        }\n        // The transform needs to be cleared so it doesn't throw off the measurements.\n        placeholder.style.transform = '';\n        // Note that the positions were already cached when we called `start` above,\n        // but we need to refresh them since the amount of items has changed.\n        this._cacheItemPositions();\n    };\n    /**\n     * Removes an item from the container after it was dragged into another container by the user.\n     * @param item Item that was dragged out.\n     */\n    /**\n     * Removes an item from the container after it was dragged into another container by the user.\n     * @param {?} item Item that was dragged out.\n     * @return {?}\n     */\n    DropListRef.prototype.exit = /**\n     * Removes an item from the container after it was dragged into another container by the user.\n     * @param {?} item Item that was dragged out.\n     * @return {?}\n     */\n    function (item) {\n        this._reset();\n        this.exited.next({ item: item, container: this });\n    };\n    /**\n     * Drops an item into this container.\n     * @param item Item being dropped into the container.\n     * @param currentIndex Index at which the item should be inserted.\n     * @param previousContainer Container from which the item got dragged in.\n     * @param isPointerOverContainer Whether the user's pointer was over the\n     *    container when the item was dropped.\n     */\n    /**\n     * Drops an item into this container.\n     * @param {?} item Item being dropped into the container.\n     * @param {?} currentIndex Index at which the item should be inserted.\n     * @param {?} previousContainer Container from which the item got dragged in.\n     * @param {?} isPointerOverContainer Whether the user's pointer was over the\n     *    container when the item was dropped.\n     * @return {?}\n     */\n    DropListRef.prototype.drop = /**\n     * Drops an item into this container.\n     * @param {?} item Item being dropped into the container.\n     * @param {?} currentIndex Index at which the item should be inserted.\n     * @param {?} previousContainer Container from which the item got dragged in.\n     * @param {?} isPointerOverContainer Whether the user's pointer was over the\n     *    container when the item was dropped.\n     * @return {?}\n     */\n    function (item, currentIndex, previousContainer, isPointerOverContainer) {\n        this._reset();\n        this.dropped.next({\n            item: item,\n            currentIndex: currentIndex,\n            previousIndex: previousContainer.getItemIndex(item),\n            container: this,\n            previousContainer: previousContainer,\n            isPointerOverContainer: isPointerOverContainer\n        });\n    };\n    /**\n     * Sets the draggable items that are a part of this list.\n     * @param items Items that are a part of this list.\n     */\n    /**\n     * Sets the draggable items that are a part of this list.\n     * @template THIS\n     * @this {THIS}\n     * @param {?} items Items that are a part of this list.\n     * @return {THIS}\n     */\n    DropListRef.prototype.withItems = /**\n     * Sets the draggable items that are a part of this list.\n     * @template THIS\n     * @this {THIS}\n     * @param {?} items Items that are a part of this list.\n     * @return {THIS}\n     */\n    function (items) {\n        var _this = this;\n        (/** @type {?} */ (this))._draggables = items;\n        items.forEach(function (item) { return item._withDropContainer((/** @type {?} */ (_this))); });\n        return (/** @type {?} */ (this));\n    };\n    /** Sets the layout direction of the drop list. */\n    /**\n     * Sets the layout direction of the drop list.\n     * @template THIS\n     * @this {THIS}\n     * @param {?} direction\n     * @return {THIS}\n     */\n    DropListRef.prototype.withDirection = /**\n     * Sets the layout direction of the drop list.\n     * @template THIS\n     * @this {THIS}\n     * @param {?} direction\n     * @return {THIS}\n     */\n    function (direction) {\n        (/** @type {?} */ (this))._direction = direction;\n        return (/** @type {?} */ (this));\n    };\n    /**\n     * Sets the containers that are connected to this one. When two or more containers are\n     * connected, the user will be allowed to transfer items between them.\n     * @param connectedTo Other containers that the current containers should be connected to.\n     */\n    /**\n     * Sets the containers that are connected to this one. When two or more containers are\n     * connected, the user will be allowed to transfer items between them.\n     * @template THIS\n     * @this {THIS}\n     * @param {?} connectedTo Other containers that the current containers should be connected to.\n     * @return {THIS}\n     */\n    DropListRef.prototype.connectedTo = /**\n     * Sets the containers that are connected to this one. When two or more containers are\n     * connected, the user will be allowed to transfer items between them.\n     * @template THIS\n     * @this {THIS}\n     * @param {?} connectedTo Other containers that the current containers should be connected to.\n     * @return {THIS}\n     */\n    function (connectedTo) {\n        (/** @type {?} */ (this))._siblings = connectedTo.slice();\n        return (/** @type {?} */ (this));\n    };\n    /**\n     * Sets the orientation of the container.\n     * @param orientation New orientation for the container.\n     */\n    /**\n     * Sets the orientation of the container.\n     * @template THIS\n     * @this {THIS}\n     * @param {?} orientation New orientation for the container.\n     * @return {THIS}\n     */\n    DropListRef.prototype.withOrientation = /**\n     * Sets the orientation of the container.\n     * @template THIS\n     * @this {THIS}\n     * @param {?} orientation New orientation for the container.\n     * @return {THIS}\n     */\n    function (orientation) {\n        (/** @type {?} */ (this))._orientation = orientation;\n        return (/** @type {?} */ (this));\n    };\n    /**\n     * Figures out the index of an item in the container.\n     * @param item Item whose index should be determined.\n     */\n    /**\n     * Figures out the index of an item in the container.\n     * @param {?} item Item whose index should be determined.\n     * @return {?}\n     */\n    DropListRef.prototype.getItemIndex = /**\n     * Figures out the index of an item in the container.\n     * @param {?} item Item whose index should be determined.\n     * @return {?}\n     */\n    function (item) {\n        if (!this._isDragging) {\n            return this._draggables.indexOf(item);\n        }\n        // Items are sorted always by top/left in the cache, however they flow differently in RTL.\n        // The rest of the logic still stands no matter what orientation we're in, however\n        // we need to invert the array when determining the index.\n        /** @type {?} */\n        var items = this._orientation === 'horizontal' && this._direction === 'rtl' ?\n            this._itemPositions.slice().reverse() : this._itemPositions;\n        return findIndex(items, function (currentItem) { return currentItem.drag === item; });\n    };\n    /**\n     * Whether the list is able to receive the item that\n     * is currently being dragged inside a connected drop list.\n     */\n    /**\n     * Whether the list is able to receive the item that\n     * is currently being dragged inside a connected drop list.\n     * @return {?}\n     */\n    DropListRef.prototype.isReceiving = /**\n     * Whether the list is able to receive the item that\n     * is currently being dragged inside a connected drop list.\n     * @return {?}\n     */\n    function () {\n        return this._activeSiblings.size > 0;\n    };\n    /**\n     * Sorts an item inside the container based on its position.\n     * @param item Item to be sorted.\n     * @param pointerX Position of the item along the X axis.\n     * @param pointerY Position of the item along the Y axis.\n     * @param pointerDelta Direction in which the pointer is moving along each axis.\n     */\n    /**\n     * Sorts an item inside the container based on its position.\n     * @param {?} item Item to be sorted.\n     * @param {?} pointerX Position of the item along the X axis.\n     * @param {?} pointerY Position of the item along the Y axis.\n     * @param {?} pointerDelta Direction in which the pointer is moving along each axis.\n     * @return {?}\n     */\n    DropListRef.prototype._sortItem = /**\n     * Sorts an item inside the container based on its position.\n     * @param {?} item Item to be sorted.\n     * @param {?} pointerX Position of the item along the X axis.\n     * @param {?} pointerY Position of the item along the Y axis.\n     * @param {?} pointerDelta Direction in which the pointer is moving along each axis.\n     * @return {?}\n     */\n    function (item, pointerX, pointerY, pointerDelta) {\n        // Don't sort the item if it's out of range.\n        if (!this._isPointerNearDropContainer(pointerX, pointerY)) {\n            return;\n        }\n        /** @type {?} */\n        var siblings = this._itemPositions;\n        /** @type {?} */\n        var newIndex = this._getItemIndexFromPointerPosition(item, pointerX, pointerY, pointerDelta);\n        if (newIndex === -1 && siblings.length > 0) {\n            return;\n        }\n        /** @type {?} */\n        var isHorizontal = this._orientation === 'horizontal';\n        /** @type {?} */\n        var currentIndex = findIndex(siblings, function (currentItem) { return currentItem.drag === item; });\n        /** @type {?} */\n        var siblingAtNewPosition = siblings[newIndex];\n        /** @type {?} */\n        var currentPosition = siblings[currentIndex].clientRect;\n        /** @type {?} */\n        var newPosition = siblingAtNewPosition.clientRect;\n        /** @type {?} */\n        var delta = currentIndex > newIndex ? 1 : -1;\n        this._previousSwap.drag = siblingAtNewPosition.drag;\n        this._previousSwap.delta = isHorizontal ? pointerDelta.x : pointerDelta.y;\n        // How many pixels the item's placeholder should be offset.\n        /** @type {?} */\n        var itemOffset = this._getItemOffsetPx(currentPosition, newPosition, delta);\n        // How many pixels all the other items should be offset.\n        /** @type {?} */\n        var siblingOffset = this._getSiblingOffsetPx(currentIndex, siblings, delta);\n        // Save the previous order of the items before moving the item to its new index.\n        // We use this to check whether an item has been moved as a result of the sorting.\n        /** @type {?} */\n        var oldOrder = siblings.slice();\n        // Shuffle the array in place.\n        moveItemInArray(siblings, currentIndex, newIndex);\n        this.sorted.next({\n            previousIndex: currentIndex,\n            currentIndex: newIndex,\n            container: this,\n            item: item\n        });\n        siblings.forEach(function (sibling, index) {\n            // Don't do anything if the position hasn't changed.\n            if (oldOrder[index] === sibling) {\n                return;\n            }\n            /** @type {?} */\n            var isDraggedItem = sibling.drag === item;\n            /** @type {?} */\n            var offset = isDraggedItem ? itemOffset : siblingOffset;\n            /** @type {?} */\n            var elementToOffset = isDraggedItem ? item.getPlaceholderElement() :\n                sibling.drag.getRootElement();\n            // Update the offset to reflect the new position.\n            sibling.offset += offset;\n            // Since we're moving the items with a `transform`, we need to adjust their cached\n            // client rects to reflect their new position, as well as swap their positions in the cache.\n            // Note that we shouldn't use `getBoundingClientRect` here to update the cache, because the\n            // elements may be mid-animation which will give us a wrong result.\n            if (isHorizontal) {\n                // Round the transforms since some browsers will\n                // blur the elements, for sub-pixel transforms.\n                elementToOffset.style.transform = \"translate3d(\" + Math.round(sibling.offset) + \"px, 0, 0)\";\n                adjustClientRect(sibling.clientRect, 0, offset);\n            }\n            else {\n                elementToOffset.style.transform = \"translate3d(0, \" + Math.round(sibling.offset) + \"px, 0)\";\n                adjustClientRect(sibling.clientRect, offset, 0);\n            }\n        });\n    };\n    /** Caches the position of the drop list. */\n    /**\n     * Caches the position of the drop list.\n     * @private\n     * @return {?}\n     */\n    DropListRef.prototype._cacheOwnPosition = /**\n     * Caches the position of the drop list.\n     * @private\n     * @return {?}\n     */\n    function () {\n        this._clientRect = this.element.getBoundingClientRect();\n    };\n    /** Refreshes the position cache of the items and sibling containers. */\n    /**\n     * Refreshes the position cache of the items and sibling containers.\n     * @private\n     * @return {?}\n     */\n    DropListRef.prototype._cacheItemPositions = /**\n     * Refreshes the position cache of the items and sibling containers.\n     * @private\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        /** @type {?} */\n        var isHorizontal = this._orientation === 'horizontal';\n        this._itemPositions = this._activeDraggables.map(function (drag) {\n            /** @type {?} */\n            var elementToMeasure = _this._dragDropRegistry.isDragging(drag) ?\n                // If the element is being dragged, we have to measure the\n                // placeholder, because the element is hidden.\n                drag.getPlaceholderElement() :\n                drag.getRootElement();\n            /** @type {?} */\n            var clientRect = elementToMeasure.getBoundingClientRect();\n            return {\n                drag: drag,\n                offset: 0,\n                // We need to clone the `clientRect` here, because all the values on it are readonly\n                // and we need to be able to update them. Also we can't use a spread here, because\n                // the values on a `ClientRect` aren't own properties. See:\n                // https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect#Notes\n                clientRect: {\n                    top: clientRect.top,\n                    right: clientRect.right,\n                    bottom: clientRect.bottom,\n                    left: clientRect.left,\n                    width: clientRect.width,\n                    height: clientRect.height\n                }\n            };\n        }).sort(function (a, b) {\n            return isHorizontal ? a.clientRect.left - b.clientRect.left :\n                a.clientRect.top - b.clientRect.top;\n        });\n    };\n    /** Resets the container to its initial state. */\n    /**\n     * Resets the container to its initial state.\n     * @private\n     * @return {?}\n     */\n    DropListRef.prototype._reset = /**\n     * Resets the container to its initial state.\n     * @private\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        this._isDragging = false;\n        // TODO(crisbeto): may have to wait for the animations to finish.\n        this._activeDraggables.forEach(function (item) { return item.getRootElement().style.transform = ''; });\n        this._siblings.forEach(function (sibling) { return sibling._stopReceiving(_this); });\n        this._activeDraggables = [];\n        this._itemPositions = [];\n        this._previousSwap.drag = null;\n        this._previousSwap.delta = 0;\n    };\n    /**\n     * Gets the offset in pixels by which the items that aren't being dragged should be moved.\n     * @param currentIndex Index of the item currently being dragged.\n     * @param siblings All of the items in the list.\n     * @param delta Direction in which the user is moving.\n     */\n    /**\n     * Gets the offset in pixels by which the items that aren't being dragged should be moved.\n     * @private\n     * @param {?} currentIndex Index of the item currently being dragged.\n     * @param {?} siblings All of the items in the list.\n     * @param {?} delta Direction in which the user is moving.\n     * @return {?}\n     */\n    DropListRef.prototype._getSiblingOffsetPx = /**\n     * Gets the offset in pixels by which the items that aren't being dragged should be moved.\n     * @private\n     * @param {?} currentIndex Index of the item currently being dragged.\n     * @param {?} siblings All of the items in the list.\n     * @param {?} delta Direction in which the user is moving.\n     * @return {?}\n     */\n    function (currentIndex, siblings, delta) {\n        /** @type {?} */\n        var isHorizontal = this._orientation === 'horizontal';\n        /** @type {?} */\n        var currentPosition = siblings[currentIndex].clientRect;\n        /** @type {?} */\n        var immediateSibling = siblings[currentIndex + delta * -1];\n        /** @type {?} */\n        var siblingOffset = currentPosition[isHorizontal ? 'width' : 'height'] * delta;\n        if (immediateSibling) {\n            /** @type {?} */\n            var start = isHorizontal ? 'left' : 'top';\n            /** @type {?} */\n            var end = isHorizontal ? 'right' : 'bottom';\n            // Get the spacing between the start of the current item and the end of the one immediately\n            // after it in the direction in which the user is dragging, or vice versa. We add it to the\n            // offset in order to push the element to where it will be when it's inline and is influenced\n            // by the `margin` of its siblings.\n            if (delta === -1) {\n                siblingOffset -= immediateSibling.clientRect[start] - currentPosition[end];\n            }\n            else {\n                siblingOffset += currentPosition[start] - immediateSibling.clientRect[end];\n            }\n        }\n        return siblingOffset;\n    };\n    /**\n     * Checks whether the pointer coordinates are close to the drop container.\n     * @param pointerX Coordinates along the X axis.\n     * @param pointerY Coordinates along the Y axis.\n     */\n    /**\n     * Checks whether the pointer coordinates are close to the drop container.\n     * @private\n     * @param {?} pointerX Coordinates along the X axis.\n     * @param {?} pointerY Coordinates along the Y axis.\n     * @return {?}\n     */\n    DropListRef.prototype._isPointerNearDropContainer = /**\n     * Checks whether the pointer coordinates are close to the drop container.\n     * @private\n     * @param {?} pointerX Coordinates along the X axis.\n     * @param {?} pointerY Coordinates along the Y axis.\n     * @return {?}\n     */\n    function (pointerX, pointerY) {\n        var _a = this._clientRect, top = _a.top, right = _a.right, bottom = _a.bottom, left = _a.left, width = _a.width, height = _a.height;\n        /** @type {?} */\n        var xThreshold = width * DROP_PROXIMITY_THRESHOLD;\n        /** @type {?} */\n        var yThreshold = height * DROP_PROXIMITY_THRESHOLD;\n        return pointerY > top - yThreshold && pointerY < bottom + yThreshold &&\n            pointerX > left - xThreshold && pointerX < right + xThreshold;\n    };\n    /**\n     * Gets the offset in pixels by which the item that is being dragged should be moved.\n     * @param currentPosition Current position of the item.\n     * @param newPosition Position of the item where the current item should be moved.\n     * @param delta Direction in which the user is moving.\n     */\n    /**\n     * Gets the offset in pixels by which the item that is being dragged should be moved.\n     * @private\n     * @param {?} currentPosition Current position of the item.\n     * @param {?} newPosition Position of the item where the current item should be moved.\n     * @param {?} delta Direction in which the user is moving.\n     * @return {?}\n     */\n    DropListRef.prototype._getItemOffsetPx = /**\n     * Gets the offset in pixels by which the item that is being dragged should be moved.\n     * @private\n     * @param {?} currentPosition Current position of the item.\n     * @param {?} newPosition Position of the item where the current item should be moved.\n     * @param {?} delta Direction in which the user is moving.\n     * @return {?}\n     */\n    function (currentPosition, newPosition, delta) {\n        /** @type {?} */\n        var isHorizontal = this._orientation === 'horizontal';\n        /** @type {?} */\n        var itemOffset = isHorizontal ? newPosition.left - currentPosition.left :\n            newPosition.top - currentPosition.top;\n        // Account for differences in the item width/height.\n        if (delta === -1) {\n            itemOffset += isHorizontal ? newPosition.width - currentPosition.width :\n                newPosition.height - currentPosition.height;\n        }\n        return itemOffset;\n    };\n    /**\n     * Gets the index of an item in the drop container, based on the position of the user's pointer.\n     * @param item Item that is being sorted.\n     * @param pointerX Position of the user's pointer along the X axis.\n     * @param pointerY Position of the user's pointer along the Y axis.\n     * @param delta Direction in which the user is moving their pointer.\n     */\n    /**\n     * Gets the index of an item in the drop container, based on the position of the user's pointer.\n     * @private\n     * @param {?} item Item that is being sorted.\n     * @param {?} pointerX Position of the user's pointer along the X axis.\n     * @param {?} pointerY Position of the user's pointer along the Y axis.\n     * @param {?=} delta Direction in which the user is moving their pointer.\n     * @return {?}\n     */\n    DropListRef.prototype._getItemIndexFromPointerPosition = /**\n     * Gets the index of an item in the drop container, based on the position of the user's pointer.\n     * @private\n     * @param {?} item Item that is being sorted.\n     * @param {?} pointerX Position of the user's pointer along the X axis.\n     * @param {?} pointerY Position of the user's pointer along the Y axis.\n     * @param {?=} delta Direction in which the user is moving their pointer.\n     * @return {?}\n     */\n    function (item, pointerX, pointerY, delta) {\n        var _this = this;\n        /** @type {?} */\n        var isHorizontal = this._orientation === 'horizontal';\n        return findIndex(this._itemPositions, function (_a, _, array) {\n            var drag = _a.drag, clientRect = _a.clientRect;\n            if (drag === item) {\n                // If there's only one item left in the container, it must be\n                // the dragged item itself so we use it as a reference.\n                return array.length < 2;\n            }\n            if (delta) {\n                /** @type {?} */\n                var direction = isHorizontal ? delta.x : delta.y;\n                // If the user is still hovering over the same item as last time, and they didn't change\n                // the direction in which they're dragging, we don't consider it a direction swap.\n                if (drag === _this._previousSwap.drag && direction === _this._previousSwap.delta) {\n                    return false;\n                }\n            }\n            return isHorizontal ?\n                // Round these down since most browsers report client rects with\n                // sub-pixel precision, whereas the pointer coordinates are rounded to pixels.\n                pointerX >= Math.floor(clientRect.left) && pointerX <= Math.floor(clientRect.right) :\n                pointerY >= Math.floor(clientRect.top) && pointerY <= Math.floor(clientRect.bottom);\n        });\n    };\n    /**\n     * Checks whether the user's pointer is positioned over the container.\n     * @param x Pointer position along the X axis.\n     * @param y Pointer position along the Y axis.\n     */\n    /**\n     * Checks whether the user's pointer is positioned over the container.\n     * @param {?} x Pointer position along the X axis.\n     * @param {?} y Pointer position along the Y axis.\n     * @return {?}\n     */\n    DropListRef.prototype._isOverContainer = /**\n     * Checks whether the user's pointer is positioned over the container.\n     * @param {?} x Pointer position along the X axis.\n     * @param {?} y Pointer position along the Y axis.\n     * @return {?}\n     */\n    function (x, y) {\n        return isInsideClientRect(this._clientRect, x, y);\n    };\n    /**\n     * Figures out whether an item should be moved into a sibling\n     * drop container, based on its current position.\n     * @param item Drag item that is being moved.\n     * @param x Position of the item along the X axis.\n     * @param y Position of the item along the Y axis.\n     */\n    /**\n     * Figures out whether an item should be moved into a sibling\n     * drop container, based on its current position.\n     * @param {?} item Drag item that is being moved.\n     * @param {?} x Position of the item along the X axis.\n     * @param {?} y Position of the item along the Y axis.\n     * @return {?}\n     */\n    DropListRef.prototype._getSiblingContainerFromPosition = /**\n     * Figures out whether an item should be moved into a sibling\n     * drop container, based on its current position.\n     * @param {?} item Drag item that is being moved.\n     * @param {?} x Position of the item along the X axis.\n     * @param {?} y Position of the item along the Y axis.\n     * @return {?}\n     */\n    function (item, x, y) {\n        return this._siblings.find(function (sibling) { return sibling._canReceive(item, x, y); });\n    };\n    /**\n     * Checks whether the drop list can receive the passed-in item.\n     * @param item Item that is being dragged into the list.\n     * @param x Position of the item along the X axis.\n     * @param y Position of the item along the Y axis.\n     */\n    /**\n     * Checks whether the drop list can receive the passed-in item.\n     * @param {?} item Item that is being dragged into the list.\n     * @param {?} x Position of the item along the X axis.\n     * @param {?} y Position of the item along the Y axis.\n     * @return {?}\n     */\n    DropListRef.prototype._canReceive = /**\n     * Checks whether the drop list can receive the passed-in item.\n     * @param {?} item Item that is being dragged into the list.\n     * @param {?} x Position of the item along the X axis.\n     * @param {?} y Position of the item along the Y axis.\n     * @return {?}\n     */\n    function (item, x, y) {\n        if (!this.enterPredicate(item, this) || !isInsideClientRect(this._clientRect, x, y)) {\n            return false;\n        }\n        /** @type {?} */\n        var elementFromPoint = this._document.elementFromPoint(x, y);\n        // If there's no element at the pointer position, then\n        // the client rect is probably scrolled out of the view.\n        if (!elementFromPoint) {\n            return false;\n        }\n        // The `ClientRect`, that we're using to find the container over which the user is\n        // hovering, doesn't give us any information on whether the element has been scrolled\n        // out of the view or whether it's overlapping with other containers. This means that\n        // we could end up transferring the item into a container that's invisible or is positioned\n        // below another one. We use the result from `elementFromPoint` to get the top-most element\n        // at the pointer position and to find whether it's one of the intersecting drop containers.\n        return elementFromPoint === this.element || this.element.contains(elementFromPoint);\n    };\n    /**\n     * Called by one of the connected drop lists when a dragging sequence has started.\n     * @param sibling Sibling in which dragging has started.\n     */\n    /**\n     * Called by one of the connected drop lists when a dragging sequence has started.\n     * @param {?} sibling Sibling in which dragging has started.\n     * @return {?}\n     */\n    DropListRef.prototype._startReceiving = /**\n     * Called by one of the connected drop lists when a dragging sequence has started.\n     * @param {?} sibling Sibling in which dragging has started.\n     * @return {?}\n     */\n    function (sibling) {\n        /** @type {?} */\n        var activeSiblings = this._activeSiblings;\n        if (!activeSiblings.has(sibling)) {\n            activeSiblings.add(sibling);\n            this._cacheOwnPosition();\n        }\n    };\n    /**\n     * Called by a connected drop list when dragging has stopped.\n     * @param sibling Sibling whose dragging has stopped.\n     */\n    /**\n     * Called by a connected drop list when dragging has stopped.\n     * @param {?} sibling Sibling whose dragging has stopped.\n     * @return {?}\n     */\n    DropListRef.prototype._stopReceiving = /**\n     * Called by a connected drop list when dragging has stopped.\n     * @param {?} sibling Sibling whose dragging has stopped.\n     * @return {?}\n     */\n    function (sibling) {\n        this._activeSiblings.delete(sibling);\n    };\n    return DropListRef;\n}());\n/**\n * Updates the top/left positions of a `ClientRect`, as well as their bottom/right counterparts.\n * @param {?} clientRect `ClientRect` that should be updated.\n * @param {?} top Amount to add to the `top` position.\n * @param {?} left Amount to add to the `left` position.\n * @return {?}\n */\nfunction adjustClientRect(clientRect, top, left) {\n    clientRect.top += top;\n    clientRect.bottom = clientRect.top + clientRect.height;\n    clientRect.left += left;\n    clientRect.right = clientRect.left + clientRect.width;\n}\n/**\n * Finds the index of an item that matches a predicate function. Used as an equivalent\n * of `Array.prototype.find` which isn't part of the standard Google typings.\n * @template T\n * @param {?} array Array in which to look for matches.\n * @param {?} predicate Function used to determine whether an item is a match.\n * @return {?}\n */\nfunction findIndex(array, predicate) {\n    for (var i = 0; i < array.length; i++) {\n        if (predicate(array[i], i, array)) {\n            return i;\n        }\n    }\n    return -1;\n}\n/**\n * Checks whether some coordinates are within a `ClientRect`.\n * @param {?} clientRect ClientRect that is being checked.\n * @param {?} x Coordinates along the X axis.\n * @param {?} y Coordinates along the Y axis.\n * @return {?}\n */\nfunction isInsideClientRect(clientRect, x, y) {\n    var top = clientRect.top, bottom = clientRect.bottom, left = clientRect.left, right = clientRect.right;\n    return y >= top && y <= bottom && x >= left && x <= right;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Event options that can be used to bind an active, capturing event.\n * @type {?}\n */\nvar activeCapturingEventOptions = normalizePassiveListenerOptions({\n    passive: false,\n    capture: true\n});\n/**\n * Service that keeps track of all the drag item and drop container\n * instances, and manages global event listeners on the `document`.\n * \\@docs-private\n * @template I, C\n */\n// Note: this class is generic, rather than referencing CdkDrag and CdkDropList directly, in order\n// to avoid circular imports. If we were to reference them here, importing the registry into the\n// classes that are registering themselves will introduce a circular import.\nvar DragDropRegistry = /** @class */ (function () {\n    function DragDropRegistry(_ngZone, _document) {\n        var _this = this;\n        this._ngZone = _ngZone;\n        /**\n         * Registered drop container instances.\n         */\n        this._dropInstances = new Set();\n        /**\n         * Registered drag item instances.\n         */\n        this._dragInstances = new Set();\n        /**\n         * Drag item instances that are currently being dragged.\n         */\n        this._activeDragInstances = new Set();\n        /**\n         * Keeps track of the event listeners that we've bound to the `document`.\n         */\n        this._globalListeners = new Map();\n        /**\n         * Emits the `touchmove` or `mousemove` events that are dispatched\n         * while the user is dragging a drag item instance.\n         */\n        this.pointerMove = new Subject();\n        /**\n         * Emits the `touchend` or `mouseup` events that are dispatched\n         * while the user is dragging a drag item instance.\n         */\n        this.pointerUp = new Subject();\n        /**\n         * Event listener that will prevent the default browser action while the user is dragging.\n         * @param event Event whose default action should be prevented.\n         */\n        this._preventDefaultWhileDragging = function (event) {\n            if (_this._activeDragInstances.size) {\n                event.preventDefault();\n            }\n        };\n        this._document = _document;\n    }\n    /** Adds a drop container to the registry. */\n    /**\n     * Adds a drop container to the registry.\n     * @param {?} drop\n     * @return {?}\n     */\n    DragDropRegistry.prototype.registerDropContainer = /**\n     * Adds a drop container to the registry.\n     * @param {?} drop\n     * @return {?}\n     */\n    function (drop) {\n        if (!this._dropInstances.has(drop)) {\n            if (this.getDropContainer(drop.id)) {\n                throw Error(\"Drop instance with id \\\"\" + drop.id + \"\\\" has already been registered.\");\n            }\n            this._dropInstances.add(drop);\n        }\n    };\n    /** Adds a drag item instance to the registry. */\n    /**\n     * Adds a drag item instance to the registry.\n     * @param {?} drag\n     * @return {?}\n     */\n    DragDropRegistry.prototype.registerDragItem = /**\n     * Adds a drag item instance to the registry.\n     * @param {?} drag\n     * @return {?}\n     */\n    function (drag) {\n        var _this = this;\n        this._dragInstances.add(drag);\n        // The `touchmove` event gets bound once, ahead of time, because WebKit\n        // won't preventDefault on a dynamically-added `touchmove` listener.\n        // See https://bugs.webkit.org/show_bug.cgi?id=184250.\n        if (this._dragInstances.size === 1) {\n            this._ngZone.runOutsideAngular(function () {\n                // The event handler has to be explicitly active,\n                // because newer browsers make it passive by default.\n                _this._document.addEventListener('touchmove', _this._preventDefaultWhileDragging, activeCapturingEventOptions);\n            });\n        }\n    };\n    /** Removes a drop container from the registry. */\n    /**\n     * Removes a drop container from the registry.\n     * @param {?} drop\n     * @return {?}\n     */\n    DragDropRegistry.prototype.removeDropContainer = /**\n     * Removes a drop container from the registry.\n     * @param {?} drop\n     * @return {?}\n     */\n    function (drop) {\n        this._dropInstances.delete(drop);\n    };\n    /** Removes a drag item instance from the registry. */\n    /**\n     * Removes a drag item instance from the registry.\n     * @param {?} drag\n     * @return {?}\n     */\n    DragDropRegistry.prototype.removeDragItem = /**\n     * Removes a drag item instance from the registry.\n     * @param {?} drag\n     * @return {?}\n     */\n    function (drag) {\n        this._dragInstances.delete(drag);\n        this.stopDragging(drag);\n        if (this._dragInstances.size === 0) {\n            this._document.removeEventListener('touchmove', this._preventDefaultWhileDragging, activeCapturingEventOptions);\n        }\n    };\n    /**\n     * Starts the dragging sequence for a drag instance.\n     * @param drag Drag instance which is being dragged.\n     * @param event Event that initiated the dragging.\n     */\n    /**\n     * Starts the dragging sequence for a drag instance.\n     * @param {?} drag Drag instance which is being dragged.\n     * @param {?} event Event that initiated the dragging.\n     * @return {?}\n     */\n    DragDropRegistry.prototype.startDragging = /**\n     * Starts the dragging sequence for a drag instance.\n     * @param {?} drag Drag instance which is being dragged.\n     * @param {?} event Event that initiated the dragging.\n     * @return {?}\n     */\n    function (drag, event) {\n        var _this = this;\n        this._activeDragInstances.add(drag);\n        if (this._activeDragInstances.size === 1) {\n            /** @type {?} */\n            var isTouchEvent = event.type.startsWith('touch');\n            /** @type {?} */\n            var moveEvent = isTouchEvent ? 'touchmove' : 'mousemove';\n            /** @type {?} */\n            var upEvent = isTouchEvent ? 'touchend' : 'mouseup';\n            // We explicitly bind __active__ listeners here, because newer browsers will default to\n            // passive ones for `mousemove` and `touchmove`. The events need to be active, because we\n            // use `preventDefault` to prevent the page from scrolling while the user is dragging.\n            this._globalListeners\n                .set(moveEvent, {\n                handler: function (e) { return _this.pointerMove.next((/** @type {?} */ (e))); },\n                options: activeCapturingEventOptions\n            })\n                .set(upEvent, {\n                handler: function (e) { return _this.pointerUp.next((/** @type {?} */ (e))); },\n                options: true\n            })\n                // Preventing the default action on `mousemove` isn't enough to disable text selection\n                // on Safari so we need to prevent the selection event as well. Alternatively this can\n                // be done by setting `user-select: none` on the `body`, however it has causes a style\n                // recalculation which can be expensive on pages with a lot of elements.\n                .set('selectstart', {\n                handler: this._preventDefaultWhileDragging,\n                options: activeCapturingEventOptions\n            });\n            // TODO(crisbeto): prevent mouse wheel scrolling while\n            // dragging until we've set up proper scroll handling.\n            if (!isTouchEvent) {\n                this._globalListeners.set('wheel', {\n                    handler: this._preventDefaultWhileDragging,\n                    options: activeCapturingEventOptions\n                });\n            }\n            this._ngZone.runOutsideAngular(function () {\n                _this._globalListeners.forEach(function (config, name) {\n                    _this._document.addEventListener(name, config.handler, config.options);\n                });\n            });\n        }\n    };\n    /** Stops dragging a drag item instance. */\n    /**\n     * Stops dragging a drag item instance.\n     * @param {?} drag\n     * @return {?}\n     */\n    DragDropRegistry.prototype.stopDragging = /**\n     * Stops dragging a drag item instance.\n     * @param {?} drag\n     * @return {?}\n     */\n    function (drag) {\n        this._activeDragInstances.delete(drag);\n        if (this._activeDragInstances.size === 0) {\n            this._clearGlobalListeners();\n        }\n    };\n    /** Gets whether a drag item instance is currently being dragged. */\n    /**\n     * Gets whether a drag item instance is currently being dragged.\n     * @param {?} drag\n     * @return {?}\n     */\n    DragDropRegistry.prototype.isDragging = /**\n     * Gets whether a drag item instance is currently being dragged.\n     * @param {?} drag\n     * @return {?}\n     */\n    function (drag) {\n        return this._activeDragInstances.has(drag);\n    };\n    /**\n     * Gets a drop container by its id.\n     * @deprecated No longer being used. To be removed.\n     * @breaking-change 8.0.0\n     */\n    /**\n     * Gets a drop container by its id.\n     * @deprecated No longer being used. To be removed.\n     * \\@breaking-change 8.0.0\n     * @param {?} id\n     * @return {?}\n     */\n    DragDropRegistry.prototype.getDropContainer = /**\n     * Gets a drop container by its id.\n     * @deprecated No longer being used. To be removed.\n     * \\@breaking-change 8.0.0\n     * @param {?} id\n     * @return {?}\n     */\n    function (id) {\n        return Array.from(this._dropInstances).find(function (instance) { return instance.id === id; });\n    };\n    /**\n     * @return {?}\n     */\n    DragDropRegistry.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        this._dragInstances.forEach(function (instance) { return _this.removeDragItem(instance); });\n        this._dropInstances.forEach(function (instance) { return _this.removeDropContainer(instance); });\n        this._clearGlobalListeners();\n        this.pointerMove.complete();\n        this.pointerUp.complete();\n    };\n    /** Clears out the global event listeners from the `document`. */\n    /**\n     * Clears out the global event listeners from the `document`.\n     * @private\n     * @return {?}\n     */\n    DragDropRegistry.prototype._clearGlobalListeners = /**\n     * Clears out the global event listeners from the `document`.\n     * @private\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        this._globalListeners.forEach(function (config, name) {\n            _this._document.removeEventListener(name, config.handler, config.options);\n        });\n        this._globalListeners.clear();\n    };\n    DragDropRegistry.decorators = [\n        { type: Injectable, args: [{ providedIn: 'root' },] },\n    ];\n    /** @nocollapse */\n    DragDropRegistry.ctorParameters = function () { return [\n        { type: NgZone },\n        { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] }\n    ]; };\n    /** @nocollapse */ DragDropRegistry.ngInjectableDef = defineInjectable({ factory: function DragDropRegistry_Factory() { return new DragDropRegistry(inject(NgZone), inject(DOCUMENT)); }, token: DragDropRegistry, providedIn: \"root\" });\n    return DragDropRegistry;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Default configuration to be used when creating a `DragRef`.\n * @type {?}\n */\nvar DEFAULT_CONFIG = {\n    dragStartThreshold: 5,\n    pointerDirectionChangeThreshold: 5\n};\n/**\n * Service that allows for drag-and-drop functionality to be attached to DOM elements.\n */\nvar DragDrop = /** @class */ (function () {\n    function DragDrop(_document, _ngZone, _viewportRuler, _dragDropRegistry) {\n        this._document = _document;\n        this._ngZone = _ngZone;\n        this._viewportRuler = _viewportRuler;\n        this._dragDropRegistry = _dragDropRegistry;\n    }\n    /**\n     * Turns an element into a draggable item.\n     * @param element Element to which to attach the dragging functionality.\n     * @param config Object used to configure the dragging behavior.\n     */\n    /**\n     * Turns an element into a draggable item.\n     * @template T\n     * @param {?} element Element to which to attach the dragging functionality.\n     * @param {?=} config Object used to configure the dragging behavior.\n     * @return {?}\n     */\n    DragDrop.prototype.createDrag = /**\n     * Turns an element into a draggable item.\n     * @template T\n     * @param {?} element Element to which to attach the dragging functionality.\n     * @param {?=} config Object used to configure the dragging behavior.\n     * @return {?}\n     */\n    function (element, config) {\n        if (config === void 0) { config = DEFAULT_CONFIG; }\n        return new DragRef(element, config, this._document, this._ngZone, this._viewportRuler, this._dragDropRegistry);\n    };\n    /**\n     * Turns an element into a drop list.\n     * @param element Element to which to attach the drop list functionality.\n     */\n    /**\n     * Turns an element into a drop list.\n     * @template T\n     * @param {?} element Element to which to attach the drop list functionality.\n     * @return {?}\n     */\n    DragDrop.prototype.createDropList = /**\n     * Turns an element into a drop list.\n     * @template T\n     * @param {?} element Element to which to attach the drop list functionality.\n     * @return {?}\n     */\n    function (element) {\n        return new DropListRef(element, this._dragDropRegistry, this._document);\n    };\n    DragDrop.decorators = [\n        { type: Injectable, args: [{ providedIn: 'root' },] },\n    ];\n    /** @nocollapse */\n    DragDrop.ctorParameters = function () { return [\n        { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },\n        { type: NgZone },\n        { type: ViewportRuler },\n        { type: DragDropRegistry }\n    ]; };\n    /** @nocollapse */ DragDrop.ngInjectableDef = defineInjectable({ factory: function DragDrop_Factory() { return new DragDrop(inject(DOCUMENT), inject(NgZone), inject(ViewportRuler), inject(DragDropRegistry)); }, token: DragDrop, providedIn: \"root\" });\n    return DragDrop;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Injection token that is used to provide a CdkDropList instance to CdkDrag.\n * Used for avoiding circular imports.\n * @type {?}\n */\nvar CDK_DROP_LIST = new InjectionToken('CDK_DROP_LIST');\n/**\n * Injection token that is used to provide a CdkDropList instance to CdkDrag.\n * Used for avoiding circular imports.\n * @deprecated Use `CDK_DROP_LIST` instead.\n * \\@breaking-change 8.0.0\n * @type {?}\n */\nvar CDK_DROP_LIST_CONTAINER = CDK_DROP_LIST;\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Injection token that can be used for a `CdkDrag` to provide itself as a parent to the\n * drag-specific child directive (`CdkDragHandle`, `CdkDragPreview` etc.). Used primarily\n * to avoid circular imports.\n * \\@docs-private\n * @type {?}\n */\nvar CDK_DRAG_PARENT = new InjectionToken('CDK_DRAG_PARENT');\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Handle that can be used to drag and CdkDrag instance.\n */\nvar CdkDragHandle = /** @class */ (function () {\n    function CdkDragHandle(element, parentDrag) {\n        this.element = element;\n        /**\n         * Emits when the state of the handle has changed.\n         */\n        this._stateChanges = new Subject();\n        this._disabled = false;\n        this._parentDrag = parentDrag;\n        toggleNativeDragInteractions(element.nativeElement, false);\n    }\n    Object.defineProperty(CdkDragHandle.prototype, \"disabled\", {\n        /** Whether starting to drag through this handle is disabled. */\n        get: /**\n         * Whether starting to drag through this handle is disabled.\n         * @return {?}\n         */\n        function () { return this._disabled; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */\n        function (value) {\n            this._disabled = coerceBooleanProperty(value);\n            this._stateChanges.next(this);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    CdkDragHandle.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        this._stateChanges.complete();\n    };\n    CdkDragHandle.decorators = [\n        { type: Directive, args: [{\n                    selector: '[cdkDragHandle]',\n                    host: {\n                        'class': 'cdk-drag-handle'\n                    }\n                },] },\n    ];\n    /** @nocollapse */\n    CdkDragHandle.ctorParameters = function () { return [\n        { type: ElementRef },\n        { type: undefined, decorators: [{ type: Inject, args: [CDK_DRAG_PARENT,] }, { type: Optional }] }\n    ]; };\n    CdkDragHandle.propDecorators = {\n        disabled: [{ type: Input, args: ['cdkDragHandleDisabled',] }]\n    };\n    return CdkDragHandle;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Element that will be used as a template for the placeholder of a CdkDrag when\n * it is being dragged. The placeholder is displayed in place of the element being dragged.\n * @template T\n */\nvar CdkDragPlaceholder = /** @class */ (function () {\n    function CdkDragPlaceholder(templateRef) {\n        this.templateRef = templateRef;\n    }\n    CdkDragPlaceholder.decorators = [\n        { type: Directive, args: [{\n                    selector: 'ng-template[cdkDragPlaceholder]'\n                },] },\n    ];\n    /** @nocollapse */\n    CdkDragPlaceholder.ctorParameters = function () { return [\n        { type: TemplateRef }\n    ]; };\n    CdkDragPlaceholder.propDecorators = {\n        data: [{ type: Input }]\n    };\n    return CdkDragPlaceholder;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Element that will be used as a template for the preview\n * of a CdkDrag when it is being dragged.\n * @template T\n */\nvar CdkDragPreview = /** @class */ (function () {\n    function CdkDragPreview(templateRef) {\n        this.templateRef = templateRef;\n    }\n    CdkDragPreview.decorators = [\n        { type: Directive, args: [{\n                    selector: 'ng-template[cdkDragPreview]'\n                },] },\n    ];\n    /** @nocollapse */\n    CdkDragPreview.ctorParameters = function () { return [\n        { type: TemplateRef }\n    ]; };\n    CdkDragPreview.propDecorators = {\n        data: [{ type: Input }]\n    };\n    return CdkDragPreview;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Injection token that can be used to configure the behavior of `CdkDrag`.\n * @type {?}\n */\nvar CDK_DRAG_CONFIG = new InjectionToken('CDK_DRAG_CONFIG', {\n    providedIn: 'root',\n    factory: CDK_DRAG_CONFIG_FACTORY\n});\n/**\n * \\@docs-private\n * @return {?}\n */\nfunction CDK_DRAG_CONFIG_FACTORY() {\n    return { dragStartThreshold: 5, pointerDirectionChangeThreshold: 5 };\n}\n/**\n * Element that can be moved inside a CdkDropList container.\n * @template T\n */\nvar CdkDrag = /** @class */ (function () {\n    function CdkDrag(element, dropContainer, _document, _ngZone, _viewContainerRef, viewportRuler, dragDropRegistry, config, _dir, \n    /**\n     * @deprecated `viewportRuler`, `dragDropRegistry` and `_changeDetectorRef` parameters\n     * to be removed. Also `dragDrop` parameter to be made required.\n     * @breaking-change 8.0.0.\n     */\n    dragDrop, _changeDetectorRef) {\n        var _this = this;\n        this.element = element;\n        this.dropContainer = dropContainer;\n        this._document = _document;\n        this._ngZone = _ngZone;\n        this._viewContainerRef = _viewContainerRef;\n        this._dir = _dir;\n        this._changeDetectorRef = _changeDetectorRef;\n        this._destroyed = new Subject();\n        this._disabled = false;\n        /**\n         * Emits when the user starts dragging the item.\n         */\n        this.started = new EventEmitter();\n        /**\n         * Emits when the user has released a drag item, before any animations have started.\n         */\n        this.released = new EventEmitter();\n        /**\n         * Emits when the user stops dragging an item in the container.\n         */\n        this.ended = new EventEmitter();\n        /**\n         * Emits when the user has moved the item into a new container.\n         */\n        this.entered = new EventEmitter();\n        /**\n         * Emits when the user removes the item its container by dragging it into another container.\n         */\n        this.exited = new EventEmitter();\n        /**\n         * Emits when the user drops the item inside a container.\n         */\n        this.dropped = new EventEmitter();\n        /**\n         * Emits as the user is dragging the item. Use with caution,\n         * because this event will fire for every pixel that the user has dragged.\n         */\n        this.moved = new Observable(function (observer) {\n            /** @type {?} */\n            var subscription = _this._dragRef.moved.pipe(map(function (movedEvent) { return ({\n                source: _this,\n                pointerPosition: movedEvent.pointerPosition,\n                event: movedEvent.event,\n                delta: movedEvent.delta\n            }); })).subscribe(observer);\n            return function () {\n                subscription.unsubscribe();\n            };\n        });\n        // @breaking-change 8.0.0 Remove null check once the paramter is made required.\n        if (dragDrop) {\n            this._dragRef = dragDrop.createDrag(element, config);\n        }\n        else {\n            this._dragRef = new DragRef(element, config, _document, _ngZone, viewportRuler, dragDropRegistry);\n        }\n        this._dragRef.data = this;\n        this._syncInputs(this._dragRef);\n        this._handleEvents(this._dragRef);\n    }\n    Object.defineProperty(CdkDrag.prototype, \"disabled\", {\n        /** Whether starting to drag this element is disabled. */\n        get: /**\n         * Whether starting to drag this element is disabled.\n         * @return {?}\n         */\n        function () {\n            return this._disabled || (this.dropContainer && this.dropContainer.disabled);\n        },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */\n        function (value) {\n            this._disabled = coerceBooleanProperty(value);\n            this._dragRef.disabled = this._disabled;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Returns the element that is being used as a placeholder\n     * while the current element is being dragged.\n     */\n    /**\n     * Returns the element that is being used as a placeholder\n     * while the current element is being dragged.\n     * @return {?}\n     */\n    CdkDrag.prototype.getPlaceholderElement = /**\n     * Returns the element that is being used as a placeholder\n     * while the current element is being dragged.\n     * @return {?}\n     */\n    function () {\n        return this._dragRef.getPlaceholderElement();\n    };\n    /** Returns the root draggable element. */\n    /**\n     * Returns the root draggable element.\n     * @return {?}\n     */\n    CdkDrag.prototype.getRootElement = /**\n     * Returns the root draggable element.\n     * @return {?}\n     */\n    function () {\n        return this._dragRef.getRootElement();\n    };\n    /** Resets a standalone drag item to its initial position. */\n    /**\n     * Resets a standalone drag item to its initial position.\n     * @return {?}\n     */\n    CdkDrag.prototype.reset = /**\n     * Resets a standalone drag item to its initial position.\n     * @return {?}\n     */\n    function () {\n        this._dragRef.reset();\n    };\n    /**\n     * @return {?}\n     */\n    CdkDrag.prototype.ngAfterViewInit = /**\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        // We need to wait for the zone to stabilize, in order for the reference\n        // element to be in the proper place in the DOM. This is mostly relevant\n        // for draggable elements inside portals since they get stamped out in\n        // their original DOM position and then they get transferred to the portal.\n        this._ngZone.onStable.asObservable()\n            .pipe(take(1), takeUntil(this._destroyed))\n            .subscribe(function () {\n            _this._updateRootElement();\n            // Listen for any newly-added handles.\n            _this._handles.changes.pipe(startWith(_this._handles), \n            // Sync the new handles with the DragRef.\n            tap(function (handles) {\n                /** @type {?} */\n                var childHandleElements = handles\n                    .filter(function (handle) { return handle._parentDrag === _this; })\n                    .map(function (handle) { return handle.element; });\n                _this._dragRef.withHandles(childHandleElements);\n            }), \n            // Listen if the state of any of the handles changes.\n            switchMap(function (handles) {\n                return merge.apply(void 0, handles.map(function (item) { return item._stateChanges; }));\n            }), takeUntil(_this._destroyed)).subscribe(function (handleInstance) {\n                // Enabled/disable the handle that changed in the DragRef.\n                /** @type {?} */\n                var dragRef = _this._dragRef;\n                /** @type {?} */\n                var handle = handleInstance.element.nativeElement;\n                handleInstance.disabled ? dragRef.disableHandle(handle) : dragRef.enableHandle(handle);\n            });\n        });\n    };\n    /**\n     * @param {?} changes\n     * @return {?}\n     */\n    CdkDrag.prototype.ngOnChanges = /**\n     * @param {?} changes\n     * @return {?}\n     */\n    function (changes) {\n        /** @type {?} */\n        var rootSelectorChange = changes['rootElementSelector'];\n        // We don't have to react to the first change since it's being\n        // handled in `ngAfterViewInit` where it needs to be deferred.\n        if (rootSelectorChange && !rootSelectorChange.firstChange) {\n            this._updateRootElement();\n        }\n    };\n    /**\n     * @return {?}\n     */\n    CdkDrag.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        this._destroyed.next();\n        this._destroyed.complete();\n        this._dragRef.dispose();\n    };\n    /** Syncs the root element with the `DragRef`. */\n    /**\n     * Syncs the root element with the `DragRef`.\n     * @private\n     * @return {?}\n     */\n    CdkDrag.prototype._updateRootElement = /**\n     * Syncs the root element with the `DragRef`.\n     * @private\n     * @return {?}\n     */\n    function () {\n        /** @type {?} */\n        var element = this.element.nativeElement;\n        /** @type {?} */\n        var rootElement = this.rootElementSelector ?\n            getClosestMatchingAncestor(element, this.rootElementSelector) : element;\n        if (rootElement && rootElement.nodeType !== this._document.ELEMENT_NODE) {\n            throw Error(\"cdkDrag must be attached to an element node. \" +\n                (\"Currently attached to \\\"\" + rootElement.nodeName + \"\\\".\"));\n        }\n        this._dragRef.withRootElement(rootElement || element);\n    };\n    /** Gets the boundary element, based on the `boundaryElementSelector`. */\n    /**\n     * Gets the boundary element, based on the `boundaryElementSelector`.\n     * @private\n     * @return {?}\n     */\n    CdkDrag.prototype._getBoundaryElement = /**\n     * Gets the boundary element, based on the `boundaryElementSelector`.\n     * @private\n     * @return {?}\n     */\n    function () {\n        /** @type {?} */\n        var selector = this.boundaryElementSelector;\n        return selector ? getClosestMatchingAncestor(this.element.nativeElement, selector) : null;\n    };\n    /** Syncs the inputs of the CdkDrag with the options of the underlying DragRef. */\n    /**\n     * Syncs the inputs of the CdkDrag with the options of the underlying DragRef.\n     * @private\n     * @param {?} ref\n     * @return {?}\n     */\n    CdkDrag.prototype._syncInputs = /**\n     * Syncs the inputs of the CdkDrag with the options of the underlying DragRef.\n     * @private\n     * @param {?} ref\n     * @return {?}\n     */\n    function (ref) {\n        var _this = this;\n        ref.beforeStarted.subscribe(function () {\n            if (!ref.isDragging()) {\n                /** @type {?} */\n                var dir = _this._dir;\n                /** @type {?} */\n                var placeholder = _this._placeholderTemplate ? {\n                    template: _this._placeholderTemplate.templateRef,\n                    context: _this._placeholderTemplate.data,\n                    viewContainer: _this._viewContainerRef\n                } : null;\n                /** @type {?} */\n                var preview = _this._previewTemplate ? {\n                    template: _this._previewTemplate.templateRef,\n                    context: _this._previewTemplate.data,\n                    viewContainer: _this._viewContainerRef\n                } : null;\n                ref.disabled = _this.disabled;\n                ref.lockAxis = _this.lockAxis;\n                ref\n                    .withBoundaryElement(_this._getBoundaryElement())\n                    .withPlaceholderTemplate(placeholder)\n                    .withPreviewTemplate(preview);\n                if (dir) {\n                    ref.withDirection(dir.value);\n                }\n            }\n        });\n    };\n    /** Handles the events from the underlying `DragRef`. */\n    /**\n     * Handles the events from the underlying `DragRef`.\n     * @private\n     * @param {?} ref\n     * @return {?}\n     */\n    CdkDrag.prototype._handleEvents = /**\n     * Handles the events from the underlying `DragRef`.\n     * @private\n     * @param {?} ref\n     * @return {?}\n     */\n    function (ref) {\n        var _this = this;\n        ref.started.subscribe(function () {\n            _this.started.emit({ source: _this });\n            // Since all of these events run outside of change detection,\n            // we need to ensure that everything is marked correctly.\n            if (_this._changeDetectorRef) {\n                // @breaking-change 8.0.0 Remove null check for _changeDetectorRef\n                _this._changeDetectorRef.markForCheck();\n            }\n        });\n        ref.released.subscribe(function () {\n            _this.released.emit({ source: _this });\n        });\n        ref.ended.subscribe(function () {\n            _this.ended.emit({ source: _this });\n            // Since all of these events run outside of change detection,\n            // we need to ensure that everything is marked correctly.\n            if (_this._changeDetectorRef) {\n                // @breaking-change 8.0.0 Remove null check for _changeDetectorRef\n                _this._changeDetectorRef.markForCheck();\n            }\n        });\n        ref.entered.subscribe(function (event) {\n            _this.entered.emit({\n                container: event.container.data,\n                item: _this\n            });\n        });\n        ref.exited.subscribe(function (event) {\n            _this.exited.emit({\n                container: event.container.data,\n                item: _this\n            });\n        });\n        ref.dropped.subscribe(function (event) {\n            _this.dropped.emit({\n                previousIndex: event.previousIndex,\n                currentIndex: event.currentIndex,\n                previousContainer: event.previousContainer.data,\n                container: event.container.data,\n                isPointerOverContainer: event.isPointerOverContainer,\n                item: _this\n            });\n        });\n    };\n    CdkDrag.decorators = [\n        { type: Directive, args: [{\n                    selector: '[cdkDrag]',\n                    exportAs: 'cdkDrag',\n                    host: {\n                        'class': 'cdk-drag',\n                        '[class.cdk-drag-disabled]': 'disabled',\n                        '[class.cdk-drag-dragging]': '_dragRef.isDragging()',\n                    },\n                    providers: [{ provide: CDK_DRAG_PARENT, useExisting: CdkDrag }]\n                },] },\n    ];\n    /** @nocollapse */\n    CdkDrag.ctorParameters = function () { return [\n        { type: ElementRef },\n        { type: undefined, decorators: [{ type: Inject, args: [CDK_DROP_LIST,] }, { type: Optional }, { type: SkipSelf }] },\n        { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },\n        { type: NgZone },\n        { type: ViewContainerRef },\n        { type: ViewportRuler },\n        { type: DragDropRegistry },\n        { type: undefined, decorators: [{ type: Inject, args: [CDK_DRAG_CONFIG,] }] },\n        { type: Directionality, decorators: [{ type: Optional }] },\n        { type: DragDrop },\n        { type: ChangeDetectorRef }\n    ]; };\n    CdkDrag.propDecorators = {\n        _handles: [{ type: ContentChildren, args: [CdkDragHandle, { descendants: true },] }],\n        _previewTemplate: [{ type: ContentChild, args: [CdkDragPreview,] }],\n        _placeholderTemplate: [{ type: ContentChild, args: [CdkDragPlaceholder,] }],\n        data: [{ type: Input, args: ['cdkDragData',] }],\n        lockAxis: [{ type: Input, args: ['cdkDragLockAxis',] }],\n        rootElementSelector: [{ type: Input, args: ['cdkDragRootElement',] }],\n        boundaryElementSelector: [{ type: Input, args: ['cdkDragBoundary',] }],\n        disabled: [{ type: Input, args: ['cdkDragDisabled',] }],\n        started: [{ type: Output, args: ['cdkDragStarted',] }],\n        released: [{ type: Output, args: ['cdkDragReleased',] }],\n        ended: [{ type: Output, args: ['cdkDragEnded',] }],\n        entered: [{ type: Output, args: ['cdkDragEntered',] }],\n        exited: [{ type: Output, args: ['cdkDragExited',] }],\n        dropped: [{ type: Output, args: ['cdkDragDropped',] }],\n        moved: [{ type: Output, args: ['cdkDragMoved',] }]\n    };\n    return CdkDrag;\n}());\n/**\n * Gets the closest ancestor of an element that matches a selector.\n * @param {?} element\n * @param {?} selector\n * @return {?}\n */\nfunction getClosestMatchingAncestor(element, selector) {\n    /** @type {?} */\n    var currentElement = (/** @type {?} */ (element.parentElement));\n    while (currentElement) {\n        // IE doesn't support `matches` so we have to fall back to `msMatchesSelector`.\n        if (currentElement.matches ? currentElement.matches(selector) :\n            ((/** @type {?} */ (currentElement))).msMatchesSelector(selector)) {\n            return currentElement;\n        }\n        currentElement = currentElement.parentElement;\n    }\n    return null;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Declaratively connects sibling `cdkDropList` instances together. All of the `cdkDropList`\n * elements that are placed inside a `cdkDropListGroup` will be connected to each other\n * automatically. Can be used as an alternative to the `cdkDropListConnectedTo` input\n * from `cdkDropList`.\n * @template T\n */\nvar CdkDropListGroup = /** @class */ (function () {\n    function CdkDropListGroup() {\n        /**\n         * Drop lists registered inside the group.\n         */\n        this._items = new Set();\n        this._disabled = false;\n    }\n    Object.defineProperty(CdkDropListGroup.prototype, \"disabled\", {\n        /** Whether starting a dragging sequence from inside this group is disabled. */\n        get: /**\n         * Whether starting a dragging sequence from inside this group is disabled.\n         * @return {?}\n         */\n        function () { return this._disabled; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */\n        function (value) {\n            this._disabled = coerceBooleanProperty(value);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    CdkDropListGroup.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        this._items.clear();\n    };\n    CdkDropListGroup.decorators = [\n        { type: Directive, args: [{\n                    selector: '[cdkDropListGroup]',\n                    exportAs: 'cdkDropListGroup',\n                },] },\n    ];\n    CdkDropListGroup.propDecorators = {\n        disabled: [{ type: Input, args: ['cdkDropListGroupDisabled',] }]\n    };\n    return CdkDropListGroup;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Counter used to generate unique ids for drop zones.\n * @type {?}\n */\nvar _uniqueIdCounter$1 = 0;\nvar 0 = undefined;\n// @breaking-change 8.0.0 `CdkDropList` implements `CdkDropListContainer` for backwards\n// compatiblity. The implements clause, as well as all the methods that it enforces can\n// be removed when `CdkDropListContainer` is deleted.\n/**\n * Container that wraps a set of draggable items.\n * @template T\n */\nvar CdkDropList = /** @class */ (function () {\n    function CdkDropList(element, dragDropRegistry, _changeDetectorRef, _dir, _group, _document, \n    /**\n     * @deprecated `dragDropRegistry` and `_document` parameters to be removed.\n     * Also `dragDrop` parameter to be made required.\n     * @breaking-change 8.0.0.\n     */\n    dragDrop) {\n        var _this = this;\n        this.element = element;\n        this._changeDetectorRef = _changeDetectorRef;\n        this._dir = _dir;\n        this._group = _group;\n        /**\n         * Emits when the list has been destroyed.\n         */\n        this._destroyed = new Subject();\n        /**\n         * Other draggable containers that this container is connected to and into which the\n         * container's items can be transferred. Can either be references to other drop containers,\n         * or their unique IDs.\n         */\n        this.connectedTo = [];\n        /**\n         * Direction in which the list is oriented.\n         */\n        this.orientation = 'vertical';\n        /**\n         * Unique ID for the drop zone. Can be used as a reference\n         * in the `connectedTo` of another `CdkDropList`.\n         */\n        this.id = \"cdk-drop-list-\" + _uniqueIdCounter$1++;\n        this._disabled = false;\n        /**\n         * Function that is used to determine whether an item\n         * is allowed to be moved into a drop container.\n         */\n        this.enterPredicate = function () { return true; };\n        /**\n         * Emits when the user drops an item inside the container.\n         */\n        this.dropped = new EventEmitter();\n        /**\n         * Emits when the user has moved a new drag item into this container.\n         */\n        this.entered = new EventEmitter();\n        /**\n         * Emits when the user removes an item from the container\n         * by dragging it into another container.\n         */\n        this.exited = new EventEmitter();\n        /**\n         * Emits as the user is swapping items while actively dragging.\n         */\n        this.sorted = new EventEmitter();\n        // @breaking-change 8.0.0 Remove null check once `dragDrop` parameter is made required.\n        if (dragDrop) {\n            this._dropListRef = dragDrop.createDropList(element);\n        }\n        else {\n            this._dropListRef = new DropListRef(element, dragDropRegistry, _document || document);\n        }\n        this._dropListRef.data = this;\n        this._dropListRef.enterPredicate = function (drag, drop) {\n            return _this.enterPredicate(drag.data, drop.data);\n        };\n        this._syncInputs(this._dropListRef);\n        this._handleEvents(this._dropListRef);\n        CdkDropList._dropLists.push(this);\n        if (_group) {\n            _group._items.add(this);\n        }\n    }\n    Object.defineProperty(CdkDropList.prototype, \"disabled\", {\n        /** Whether starting a dragging sequence from this container is disabled. */\n        get: /**\n         * Whether starting a dragging sequence from this container is disabled.\n         * @return {?}\n         */\n        function () {\n            return this._disabled || (!!this._group && this._group.disabled);\n        },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */\n        function (value) {\n            this._disabled = coerceBooleanProperty(value);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    CdkDropList.prototype.ngAfterContentInit = /**\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        this._draggables.changes\n            .pipe(startWith(this._draggables), takeUntil(this._destroyed))\n            .subscribe(function (items) {\n            _this._dropListRef.withItems(items.map(function (drag) { return drag._dragRef; }));\n        });\n    };\n    /**\n     * @return {?}\n     */\n    CdkDropList.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        /** @type {?} */\n        var index = CdkDropList._dropLists.indexOf(this);\n        if (index > -1) {\n            CdkDropList._dropLists.splice(index, 1);\n        }\n        if (this._group) {\n            this._group._items.delete(this);\n        }\n        this._dropListRef.dispose();\n        this._destroyed.next();\n        this._destroyed.complete();\n    };\n    /** Starts dragging an item. */\n    /**\n     * Starts dragging an item.\n     * @return {?}\n     */\n    CdkDropList.prototype.start = /**\n     * Starts dragging an item.\n     * @return {?}\n     */\n    function () {\n        this._dropListRef.start();\n    };\n    /**\n     * Drops an item into this container.\n     * @param item Item being dropped into the container.\n     * @param currentIndex Index at which the item should be inserted.\n     * @param previousContainer Container from which the item got dragged in.\n     * @param isPointerOverContainer Whether the user's pointer was over the\n     *    container when the item was dropped.\n     */\n    /**\n     * Drops an item into this container.\n     * @param {?} item Item being dropped into the container.\n     * @param {?} currentIndex Index at which the item should be inserted.\n     * @param {?} previousContainer Container from which the item got dragged in.\n     * @param {?} isPointerOverContainer Whether the user's pointer was over the\n     *    container when the item was dropped.\n     * @return {?}\n     */\n    CdkDropList.prototype.drop = /**\n     * Drops an item into this container.\n     * @param {?} item Item being dropped into the container.\n     * @param {?} currentIndex Index at which the item should be inserted.\n     * @param {?} previousContainer Container from which the item got dragged in.\n     * @param {?} isPointerOverContainer Whether the user's pointer was over the\n     *    container when the item was dropped.\n     * @return {?}\n     */\n    function (item, currentIndex, previousContainer, isPointerOverContainer) {\n        this._dropListRef.drop(item._dragRef, currentIndex, ((/** @type {?} */ (previousContainer)))._dropListRef, isPointerOverContainer);\n    };\n    /**\n     * Emits an event to indicate that the user moved an item into the container.\n     * @param item Item that was moved into the container.\n     * @param pointerX Position of the item along the X axis.\n     * @param pointerY Position of the item along the Y axis.\n     */\n    /**\n     * Emits an event to indicate that the user moved an item into the container.\n     * @param {?} item Item that was moved into the container.\n     * @param {?} pointerX Position of the item along the X axis.\n     * @param {?} pointerY Position of the item along the Y axis.\n     * @return {?}\n     */\n    CdkDropList.prototype.enter = /**\n     * Emits an event to indicate that the user moved an item into the container.\n     * @param {?} item Item that was moved into the container.\n     * @param {?} pointerX Position of the item along the X axis.\n     * @param {?} pointerY Position of the item along the Y axis.\n     * @return {?}\n     */\n    function (item, pointerX, pointerY) {\n        this._dropListRef.enter(item._dragRef, pointerX, pointerY);\n    };\n    /**\n     * Removes an item from the container after it was dragged into another container by the user.\n     * @param item Item that was dragged out.\n     */\n    /**\n     * Removes an item from the container after it was dragged into another container by the user.\n     * @param {?} item Item that was dragged out.\n     * @return {?}\n     */\n    CdkDropList.prototype.exit = /**\n     * Removes an item from the container after it was dragged into another container by the user.\n     * @param {?} item Item that was dragged out.\n     * @return {?}\n     */\n    function (item) {\n        this._dropListRef.exit(item._dragRef);\n    };\n    /**\n     * Figures out the index of an item in the container.\n     * @param item Item whose index should be determined.\n     */\n    /**\n     * Figures out the index of an item in the container.\n     * @param {?} item Item whose index should be determined.\n     * @return {?}\n     */\n    CdkDropList.prototype.getItemIndex = /**\n     * Figures out the index of an item in the container.\n     * @param {?} item Item whose index should be determined.\n     * @return {?}\n     */\n    function (item) {\n        return this._dropListRef.getItemIndex(item._dragRef);\n    };\n    /**\n     * Sorts an item inside the container based on its position.\n     * @param item Item to be sorted.\n     * @param pointerX Position of the item along the X axis.\n     * @param pointerY Position of the item along the Y axis.\n     * @param pointerDelta Direction in which the pointer is moving along each axis.\n     */\n    /**\n     * Sorts an item inside the container based on its position.\n     * @param {?} item Item to be sorted.\n     * @param {?} pointerX Position of the item along the X axis.\n     * @param {?} pointerY Position of the item along the Y axis.\n     * @param {?} pointerDelta Direction in which the pointer is moving along each axis.\n     * @return {?}\n     */\n    CdkDropList.prototype._sortItem = /**\n     * Sorts an item inside the container based on its position.\n     * @param {?} item Item to be sorted.\n     * @param {?} pointerX Position of the item along the X axis.\n     * @param {?} pointerY Position of the item along the Y axis.\n     * @param {?} pointerDelta Direction in which the pointer is moving along each axis.\n     * @return {?}\n     */\n    function (item, pointerX, pointerY, pointerDelta) {\n        return this._dropListRef._sortItem(item._dragRef, pointerX, pointerY, pointerDelta);\n    };\n    /**\n     * Figures out whether an item should be moved into a sibling\n     * drop container, based on its current position.\n     * @param item Drag item that is being moved.\n     * @param x Position of the item along the X axis.\n     * @param y Position of the item along the Y axis.\n     */\n    /**\n     * Figures out whether an item should be moved into a sibling\n     * drop container, based on its current position.\n     * @param {?} item Drag item that is being moved.\n     * @param {?} x Position of the item along the X axis.\n     * @param {?} y Position of the item along the Y axis.\n     * @return {?}\n     */\n    CdkDropList.prototype._getSiblingContainerFromPosition = /**\n     * Figures out whether an item should be moved into a sibling\n     * drop container, based on its current position.\n     * @param {?} item Drag item that is being moved.\n     * @param {?} x Position of the item along the X axis.\n     * @param {?} y Position of the item along the Y axis.\n     * @return {?}\n     */\n    function (item, x, y) {\n        /** @type {?} */\n        var result = this._dropListRef._getSiblingContainerFromPosition(item._dragRef, x, y);\n        return result ? result.data : null;\n    };\n    /**\n     * Checks whether the user's pointer is positioned over the container.\n     * @param x Pointer position along the X axis.\n     * @param y Pointer position along the Y axis.\n     */\n    /**\n     * Checks whether the user's pointer is positioned over the container.\n     * @param {?} x Pointer position along the X axis.\n     * @param {?} y Pointer position along the Y axis.\n     * @return {?}\n     */\n    CdkDropList.prototype._isOverContainer = /**\n     * Checks whether the user's pointer is positioned over the container.\n     * @param {?} x Pointer position along the X axis.\n     * @param {?} y Pointer position along the Y axis.\n     * @return {?}\n     */\n    function (x, y) {\n        return this._dropListRef._isOverContainer(x, y);\n    };\n    /** Syncs the inputs of the CdkDropList with the options of the underlying DropListRef. */\n    /**\n     * Syncs the inputs of the CdkDropList with the options of the underlying DropListRef.\n     * @private\n     * @param {?} ref\n     * @return {?}\n     */\n    CdkDropList.prototype._syncInputs = /**\n     * Syncs the inputs of the CdkDropList with the options of the underlying DropListRef.\n     * @private\n     * @param {?} ref\n     * @return {?}\n     */\n    function (ref) {\n        var _this = this;\n        if (this._dir) {\n            this._dir.change\n                .pipe(startWith(this._dir.value), takeUntil(this._destroyed))\n                .subscribe(function (value) { return ref.withDirection(value); });\n        }\n        ref.beforeStarted.subscribe(function () {\n            /** @type {?} */\n            var siblings = coerceArray(_this.connectedTo).map(function (drop) {\n                return typeof drop === 'string' ?\n                    (/** @type {?} */ (CdkDropList._dropLists.find(function (list) { return list.id === drop; }))) : drop;\n            });\n            if (_this._group) {\n                _this._group._items.forEach(function (drop) {\n                    if (siblings.indexOf(drop) === -1) {\n                        siblings.push(drop);\n                    }\n                });\n            }\n            ref.lockAxis = _this.lockAxis;\n            ref\n                .connectedTo(siblings.filter(function (drop) { return drop && drop !== _this; }).map(function (list) { return list._dropListRef; }))\n                .withOrientation(_this.orientation);\n        });\n    };\n    /** Handles events from the underlying DropListRef. */\n    /**\n     * Handles events from the underlying DropListRef.\n     * @private\n     * @param {?} ref\n     * @return {?}\n     */\n    CdkDropList.prototype._handleEvents = /**\n     * Handles events from the underlying DropListRef.\n     * @private\n     * @param {?} ref\n     * @return {?}\n     */\n    function (ref) {\n        var _this = this;\n        ref.beforeStarted.subscribe(function () {\n            _this._changeDetectorRef.markForCheck();\n        });\n        ref.entered.subscribe(function (event) {\n            _this.entered.emit({\n                container: _this,\n                item: event.item.data\n            });\n        });\n        ref.exited.subscribe(function (event) {\n            _this.exited.emit({\n                container: _this,\n                item: event.item.data\n            });\n        });\n        ref.sorted.subscribe(function (event) {\n            _this.sorted.emit({\n                previousIndex: event.previousIndex,\n                currentIndex: event.currentIndex,\n                container: _this,\n                item: event.item.data\n            });\n        });\n        ref.dropped.subscribe(function (event) {\n            _this.dropped.emit({\n                previousIndex: event.previousIndex,\n                currentIndex: event.currentIndex,\n                previousContainer: event.previousContainer.data,\n                container: event.container.data,\n                item: event.item.data,\n                isPointerOverContainer: event.isPointerOverContainer\n            });\n            // Mark for check since all of these events run outside of change\n            // detection and we're not guaranteed for something else to have triggered it.\n            _this._changeDetectorRef.markForCheck();\n        });\n    };\n    /**\n     * Keeps track of the drop lists that are currently on the page.\n     */\n    CdkDropList._dropLists = [];\n    CdkDropList.decorators = [\n        { type: Directive, args: [{\n                    selector: '[cdkDropList], cdk-drop-list',\n                    exportAs: 'cdkDropList',\n                    providers: [\n                        // Prevent child drop lists from picking up the same group as their parent.\n                        { provide: CdkDropListGroup, useValue: 0 },\n                        { provide: CDK_DROP_LIST_CONTAINER, useExisting: CdkDropList },\n                    ],\n                    host: {\n                        'class': 'cdk-drop-list',\n                        '[id]': 'id',\n                        '[class.cdk-drop-list-disabled]': 'disabled',\n                        '[class.cdk-drop-list-dragging]': '_dropListRef.isDragging()',\n                        '[class.cdk-drop-list-receiving]': '_dropListRef.isReceiving()',\n                    }\n                },] },\n    ];\n    /** @nocollapse */\n    CdkDropList.ctorParameters = function () { return [\n        { type: ElementRef },\n        { type: DragDropRegistry },\n        { type: ChangeDetectorRef },\n        { type: Directionality, decorators: [{ type: Optional }] },\n        { type: CdkDropListGroup, decorators: [{ type: Optional }, { type: SkipSelf }] },\n        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DOCUMENT,] }] },\n        { type: DragDrop }\n    ]; };\n    CdkDropList.propDecorators = {\n        _draggables: [{ type: ContentChildren, args: [forwardRef(function () { return CdkDrag; }), {\n                        // Explicitly set to false since some of the logic below makes assumptions about it.\n                        // The `.withItems` call below should be updated if we ever need to switch this to `true`.\n                        descendants: false\n                    },] }],\n        connectedTo: [{ type: Input, args: ['cdkDropListConnectedTo',] }],\n        data: [{ type: Input, args: ['cdkDropListData',] }],\n        orientation: [{ type: Input, args: ['cdkDropListOrientation',] }],\n        id: [{ type: Input }],\n        lockAxis: [{ type: Input, args: ['cdkDropListLockAxis',] }],\n        disabled: [{ type: Input, args: ['cdkDropListDisabled',] }],\n        enterPredicate: [{ type: Input, args: ['cdkDropListEnterPredicate',] }],\n        dropped: [{ type: Output, args: ['cdkDropListDropped',] }],\n        entered: [{ type: Output, args: ['cdkDropListEntered',] }],\n        exited: [{ type: Output, args: ['cdkDropListExited',] }],\n        sorted: [{ type: Output, args: ['cdkDropListSorted',] }]\n    };\n    return CdkDropList;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar DragDropModule = /** @class */ (function () {\n    function DragDropModule() {\n    }\n    DragDropModule.decorators = [\n        { type: NgModule, args: [{\n                    declarations: [\n                        CdkDropList,\n                        CdkDropListGroup,\n                        CdkDrag,\n                        CdkDragHandle,\n                        CdkDragPreview,\n                        CdkDragPlaceholder,\n                    ],\n                    exports: [\n                        CdkDropList,\n                        CdkDropListGroup,\n                        CdkDrag,\n                        CdkDragHandle,\n                        CdkDragPreview,\n                        CdkDragPlaceholder,\n                    ],\n                    providers: [\n                        DragDrop,\n                    ]\n                },] },\n    ];\n    return DragDropModule;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\nexport { DragDrop, DragRef, DropListRef, CdkDropList, CDK_DROP_LIST, CDK_DROP_LIST_CONTAINER, moveItemInArray, transferArrayItem, copyArrayItem, DragDropModule, DragDropRegistry, CdkDropListGroup, CDK_DRAG_CONFIG_FACTORY, CDK_DRAG_CONFIG, CdkDrag, CdkDragHandle, CdkDragPreview, CdkDragPlaceholder, CDK_DRAG_PARENT as b };\n//# sourceMappingURL=drag-drop.es5.js.map\n","/**\n * @fileoverview This file was generated by the Angular template compiler. Do not edit.\n *\n * @suppress {suspiciousCode,uselessCode,missingProperties,missingOverride,checkTypes}\n * tslint:disable\n */ \nvar styles = [\"[_nghost-%COMP%]{margin-bottom:24px;display:block}\"];\nexport { styles as styles };\n","/**\n * @fileoverview This file was generated by the Angular template compiler. Do not edit.\n *\n * @suppress {suspiciousCode,uselessCode,missingProperties,missingOverride,checkTypes}\n * tslint:disable\n */ \nimport * as i0 from \"./breadcrumbs.component.scss.shim.ngstyle\";\nimport * as i1 from \"@angular/core\";\nimport * as i2 from \"@angular/router\";\nimport * as i3 from \"@angular/common\";\nimport * as i4 from \"../../../../node_modules/@angular/material/icon/typings/index.ngfactory\";\nimport * as i5 from \"@angular/material/icon\";\nimport * as i6 from \"@angular/flex-layout/flex\";\nimport * as i7 from \"@angular/flex-layout/core\";\nimport * as i8 from \"./breadcrumbs.component\";\nvar styles_BreadcrumbsComponent = [i0.styles];\nvar RenderType_BreadcrumbsComponent = i1.crt({ encapsulation: 0, styles: styles_BreadcrumbsComponent, data: {} });\nexport { RenderType_BreadcrumbsComponent as RenderType_BreadcrumbsComponent };\nfunction View_BreadcrumbsComponent_2(_l) { return i1.vid(0, [(_l()(), i1.eld(0, 0, null, null, 3, \"a\", [[\"class\", \"crumb link\"]], [[1, \"target\", 0], [8, \"href\", 4]], [[null, \"click\"]], function (_v, en, $event) { var ad = true; if ((\"click\" === en)) {\n        var pd_0 = (i1.nov(_v, 1).onClick($event.button, $event.ctrlKey, $event.metaKey, $event.shiftKey) !== false);\n        ad = (pd_0 && ad);\n    } return ad; }, null, null)), i1.did(1, 671744, null, 0, i2.RouterLinkWithHref, [i2.Router, i2.ActivatedRoute, i3.LocationStrategy], { routerLink: [0, \"routerLink\"] }, null), i1.pad(2, 1), (_l()(), i1.ted(3, null, [\"\", \"\"]))], function (_ck, _v) { var currVal_2 = _ck(_v, 2, 0, _v.parent.context.$implicit.link); _ck(_v, 1, 0, currVal_2); }, function (_ck, _v) { var currVal_0 = i1.nov(_v, 1).target; var currVal_1 = i1.nov(_v, 1).href; _ck(_v, 0, 0, currVal_0, currVal_1); var currVal_3 = _v.parent.context.$implicit.name; _ck(_v, 3, 0, currVal_3); }); }\nfunction View_BreadcrumbsComponent_3(_l) { return i1.vid(0, [(_l()(), i1.eld(0, 0, null, null, 1, \"div\", [[\"class\", \"link\"]], null, null, null, null, null)), (_l()(), i1.ted(1, null, [\"\", \"\"]))], null, function (_ck, _v) { var currVal_0 = _v.parent.context.$implicit.name; _ck(_v, 1, 0, currVal_0); }); }\nfunction View_BreadcrumbsComponent_4(_l) { return i1.vid(0, [(_l()(), i1.eld(0, 0, null, null, 2, \"mat-icon\", [[\"class\", \"chevron mat-icon notranslate\"], [\"role\", \"img\"]], [[2, \"mat-icon-inline\", null], [2, \"mat-icon-no-color\", null]], null, null, i4.View_MatIcon_0, i4.RenderType_MatIcon)), i1.did(1, 9158656, null, 0, i5.MatIcon, [i1.ElementRef, i5.MatIconRegistry, [8, null], [2, i5.MAT_ICON_LOCATION]], null, null), (_l()(), i1.ted(-1, 0, [\"chevron_right\"]))], function (_ck, _v) { _ck(_v, 1, 0); }, function (_ck, _v) { var currVal_0 = i1.nov(_v, 1).inline; var currVal_1 = (((i1.nov(_v, 1).color !== \"primary\") && (i1.nov(_v, 1).color !== \"accent\")) && (i1.nov(_v, 1).color !== \"warn\")); _ck(_v, 0, 0, currVal_0, currVal_1); }); }\nfunction View_BreadcrumbsComponent_1(_l) { return i1.vid(0, [(_l()(), i1.eld(0, 0, null, null, 9, \"div\", [[\"class\", \"crumb\"], [\"fxLayout\", \"row\"], [\"fxLayoutAlign\", \"start center\"]], null, null, null, null, null)), i1.did(1, 671744, null, 0, i6.DefaultLayoutDirective, [i1.ElementRef, i7.StyleUtils, [2, i6.LayoutStyleBuilder], i7.MediaMarshaller], { fxLayout: [0, \"fxLayout\"] }, null), i1.did(2, 671744, null, 0, i6.DefaultLayoutAlignDirective, [i1.ElementRef, i7.StyleUtils, [2, i6.LayoutAlignStyleBuilder], i7.MediaMarshaller], { fxLayoutAlign: [0, \"fxLayoutAlign\"] }, null), i1.did(3, 16384, null, 0, i3.NgSwitch, [], { ngSwitch: [0, \"ngSwitch\"] }, null), (_l()(), i1.and(16777216, null, null, 1, null, View_BreadcrumbsComponent_2)), i1.did(5, 278528, null, 0, i3.NgSwitchCase, [i1.ViewContainerRef, i1.TemplateRef, i3.NgSwitch], { ngSwitchCase: [0, \"ngSwitchCase\"] }, null), (_l()(), i1.and(16777216, null, null, 1, null, View_BreadcrumbsComponent_3)), i1.did(7, 16384, null, 0, i3.NgSwitchDefault, [i1.ViewContainerRef, i1.TemplateRef, i3.NgSwitch], null, null), (_l()(), i1.and(16777216, null, null, 1, null, View_BreadcrumbsComponent_4)), i1.did(9, 16384, null, 0, i3.NgIf, [i1.ViewContainerRef, i1.TemplateRef], { ngIf: [0, \"ngIf\"] }, null)], function (_ck, _v) { var currVal_0 = \"row\"; _ck(_v, 1, 0, currVal_0); var currVal_1 = \"start center\"; _ck(_v, 2, 0, currVal_1); var currVal_2 = !!_v.context.$implicit.link; _ck(_v, 3, 0, currVal_2); var currVal_3 = true; _ck(_v, 5, 0, currVal_3); var currVal_4 = !_v.context.last; _ck(_v, 9, 0, currVal_4); }, null); }\nexport function View_BreadcrumbsComponent_0(_l) { return i1.vid(2, [(_l()(), i1.eld(0, 0, null, null, 1, \"div\", [[\"class\", \"title\"]], null, null, null, null, null)), (_l()(), i1.ted(1, null, [\"\", \"\"])), (_l()(), i1.eld(2, 0, null, null, 4, \"div\", [[\"class\", \"crumbs\"], [\"fxLayout\", \"row\"], [\"fxLayoutAlign\", \"start center\"]], null, null, null, null, null)), i1.did(3, 671744, null, 0, i6.DefaultLayoutDirective, [i1.ElementRef, i7.StyleUtils, [2, i6.LayoutStyleBuilder], i7.MediaMarshaller], { fxLayout: [0, \"fxLayout\"] }, null), i1.did(4, 671744, null, 0, i6.DefaultLayoutAlignDirective, [i1.ElementRef, i7.StyleUtils, [2, i6.LayoutAlignStyleBuilder], i7.MediaMarshaller], { fxLayoutAlign: [0, \"fxLayoutAlign\"] }, null), (_l()(), i1.and(16777216, null, null, 1, null, View_BreadcrumbsComponent_1)), i1.did(6, 278528, null, 0, i3.NgForOf, [i1.ViewContainerRef, i1.TemplateRef, i1.IterableDiffers], { ngForOf: [0, \"ngForOf\"] }, null)], function (_ck, _v) { var _co = _v.component; var currVal_1 = \"row\"; _ck(_v, 3, 0, currVal_1); var currVal_2 = \"start center\"; _ck(_v, 4, 0, currVal_2); var currVal_3 = _co.crumbs; _ck(_v, 6, 0, currVal_3); }, function (_ck, _v) { var _co = _v.component; var currVal_0 = _co.title; _ck(_v, 1, 0, currVal_0); }); }\nexport function View_BreadcrumbsComponent_Host_0(_l) { return i1.vid(0, [(_l()(), i1.eld(0, 0, null, null, 1, \"ngx-breadcrumbs\", [], null, null, null, View_BreadcrumbsComponent_0, RenderType_BreadcrumbsComponent)), i1.did(1, 114688, null, 0, i8.BreadcrumbsComponent, [], null, null)], function (_ck, _v) { _ck(_v, 1, 0); }, null); }\nvar BreadcrumbsComponentNgFactory = i1.ccf(\"ngx-breadcrumbs\", i8.BreadcrumbsComponent, View_BreadcrumbsComponent_Host_0, { title: \"title\", crumbs: \"crumbs\" }, {}, []);\nexport { BreadcrumbsComponentNgFactory as BreadcrumbsComponentNgFactory };\n","<div class=\"title\">{{ title }}</div>\n<div class=\"crumbs\" fxLayout=\"row\" fxLayoutAlign=\"start center\">\n  <div\n    class=\"crumb\"\n    *ngFor=\"let crumb of crumbs; let last = last\"\n    [ngSwitch]=\"!!crumb.link\"\n    fxLayout=\"row\"\n    fxLayoutAlign=\"start center\"\n  >\n    <a *ngSwitchCase=\"true\" class=\"crumb link\" [routerLink]=\"[crumb.link]\">{{ crumb.name }}</a>\n    <div *ngSwitchDefault class=\"link\">{{ crumb.name }}</div>\n    <mat-icon *ngIf=\"!last\" class=\"chevron\">chevron_right</mat-icon>\n  </div>\n</div>\n"],"sourceRoot":""}