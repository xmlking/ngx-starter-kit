{"version":3,"sources":["webpack:////Developer/Work/SPA/ngx-starter-kit/node_modules/@angular/material/esm5/menu.es5.js.pre-build-optimizer.js"],"names":["__webpack_require__","d","__webpack_exports__","MAT_MENU_SCROLL_STRATEGY","MatMenuModule","MatMenu","MAT_MENU_DEFAULT_OPTIONS","MatMenuItem","MatMenuTrigger","MAT_MENU_PANEL","MAT_MENU_SCROLL_STRATEGY_FACTORY","_angular_core__WEBPACK_IMPORTED_MODULE_0__","_angular_cdk_portal__WEBPACK_IMPORTED_MODULE_1__","rxjs__WEBPACK_IMPORTED_MODULE_2__","rxjs__WEBPACK_IMPORTED_MODULE_3__","rxjs__WEBPACK_IMPORTED_MODULE_4__","rxjs__WEBPACK_IMPORTED_MODULE_5__","rxjs__WEBPACK_IMPORTED_MODULE_6__","tslib__WEBPACK_IMPORTED_MODULE_8__","_angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_9__","_angular_material_core__WEBPACK_IMPORTED_MODULE_10__","_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_11__","_angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_12__","rxjs_operators__WEBPACK_IMPORTED_MODULE_13__","rxjs_operators__WEBPACK_IMPORTED_MODULE_14__","rxjs_operators__WEBPACK_IMPORTED_MODULE_15__","rxjs_operators__WEBPACK_IMPORTED_MODULE_16__","rxjs_operators__WEBPACK_IMPORTED_MODULE_17__","rxjs_operators__WEBPACK_IMPORTED_MODULE_18__","_angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_19__","_angular_cdk_platform__WEBPACK_IMPORTED_MODULE_20__","MatMenuItemBase","_super","_elementRef","document","_focusMonitor","_parentMenu","_this","call","this","role","_hovered","_highlighted","_triggersSubmenu","monitor","addItem","_document","Object","prototype","focus","origin","focusVia","_getHostElement","ngOnDestroy","stopMonitoring","removeItem","complete","_getTabIndex","disabled","nativeElement","_checkDisabled","event","preventDefault","stopPropagation","_handleMouseEnter","next","getLabel","element","textNodeType","TEXT_NODE","output","childNodes","length_1","length","i","nodeType","textContent","trim","providedIn","factory","overlapTrigger","xPosition","yPosition","backdropClass","_ngZone","_defaultOptions","_xPosition","_yPosition","_items","_itemChanges","_tabSubscription","EMPTY","_classList","_panelAnimationState","_animationDone","_overlapTrigger","_hasBackdrop","hasBackdrop","closed","close","defineProperty","get","set","value","Error","throwMatMenuInvalidPositionX","setPositionClasses","enumerable","configurable","throwMatMenuInvalidPositionY","classes","previousPanelClass","_previousPanelClass","split","forEach","className","panelClass","ngOnInit","ngAfterContentInit","_keyManager","withWrap","withTypeAhead","tabOut","subscribe","emit","unsubscribe","pipe","items","apply","map","item","_handleKeydown","keyCode","manager","parentMenu","direction","setFirstItemActive","setLastItemActive","setFocusOrigin","onKeydown","focusFirstItem","lazyContent","onStable","asObservable","resetActiveItem","setActiveItem","setElevation","depth","newElevation","customElevation","keys","find","c","startsWith","_previousElevation","indexOf","push","index","splice","posX","posY","_startAnimation","_resetAnimation","_onAnimationDone","_isAnimating","_onAnimationStart","toState","activeItemIndex","scrollTop","overlay","scrollStrategies","reposition","passiveEventListenerOptions","passive","_overlay","_element","_viewContainerRef","scrollStrategy","_menuItemInstance","_dir","_overlayRef","_menuOpen","_closingActionsSubscription","_hoverSubscription","_menuCloseSubscription","_handleTouchStart","_openedBy","restoreFocus","menuOpened","onMenuOpen","menuClosed","onMenuClose","addEventListener","triggersSubmenu","_scrollStrategy","menu","v","_menu","reason","_destroyMenu","_checkMenu","_handleHover","dispose","removeEventListener","_cleanUpSubscriptions","toggleMenu","closeMenu","openMenu","overlayRef","_createOverlay","overlayConfig","getConfig","_setPosition","attach","_getPortal","menuData","_menuClosingActions","_initMenu","menuOpen","detach","_attached","undefined","_resetMenu","dir","_setMenuElevation","_setIsMenuOpen","isOpen","throwMatMenuMissingError","config","_getOverlayConfig","_subscribeToPositions","create","keydownEvents","positionStrategy","position","flexibleConnectedTo","withLockedPosition","withTransformOriginOn","positionChanges","change","connectionPair","overlayX","overlayY","_a","originX","originFallbackX","_b","overlayFallbackY","_c","originY","originFallbackY","_d","overlayFallbackX","offsetY","withPositions","backdrop","backdropClick","detachments","parentClose","hover","active","_handleMousedown","button","_handleClick","_portal","templateRef"],"mappings":"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","file":"6.ad5829ebb7bd4216da0a.js","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Directive, TemplateRef, ComponentFactoryResolver, ApplicationRef, Injector, ViewContainerRef, Inject, InjectionToken, ChangeDetectionStrategy, Component, ElementRef, ViewEncapsulation, Optional, Input, ContentChild, ContentChildren, EventEmitter, NgZone, Output, ViewChild, Self, NgModule } from '@angular/core';\nimport { TemplatePortal, DomPortalOutlet } from '@angular/cdk/portal';\nimport { DOCUMENT, CommonModule } from '@angular/common';\nimport { Subject, merge, Subscription, asapScheduler, of } from 'rxjs';\nimport { trigger, state, style, animate, transition, query, group } from '@angular/animations';\nimport { __extends } from 'tslib';\nimport { FocusMonitor, FocusKeyManager, isFakeMousedownFromScreenReader } from '@angular/cdk/a11y';\nimport { mixinDisabled, mixinDisableRipple, MatCommonModule, MatRippleModule } from '@angular/material/core';\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport { ESCAPE, LEFT_ARROW, RIGHT_ARROW, DOWN_ARROW, UP_ARROW, HOME, END, hasModifierKey } from '@angular/cdk/keycodes';\nimport { startWith, switchMap, take, delay, filter, takeUntil } from 'rxjs/operators';\nimport { Directionality } from '@angular/cdk/bidi';\nimport { Overlay, OverlayConfig, OverlayModule } from '@angular/cdk/overlay';\nimport { normalizePassiveListenerOptions } from '@angular/cdk/platform';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Menu content that will be rendered lazily once the menu is opened.\n */\nvar MatMenuContent = /** @class */ (function () {\n    function MatMenuContent(_template, _componentFactoryResolver, _appRef, _injector, _viewContainerRef, _document) {\n        this._template = _template;\n        this._componentFactoryResolver = _componentFactoryResolver;\n        this._appRef = _appRef;\n        this._injector = _injector;\n        this._viewContainerRef = _viewContainerRef;\n        this._document = _document;\n        /**\n         * Emits when the menu content has been attached.\n         */\n        this._attached = new Subject();\n    }\n    /**\n     * Attaches the content with a particular context.\n     * @docs-private\n     */\n    /**\n     * Attaches the content with a particular context.\n     * \\@docs-private\n     * @param {?=} context\n     * @return {?}\n     */\n    MatMenuContent.prototype.attach = /**\n     * Attaches the content with a particular context.\n     * \\@docs-private\n     * @param {?=} context\n     * @return {?}\n     */\n    function (context) {\n        if (context === void 0) { context = {}; }\n        if (!this._portal) {\n            this._portal = new TemplatePortal(this._template, this._viewContainerRef);\n        }\n        this.detach();\n        if (!this._outlet) {\n            this._outlet = new DomPortalOutlet(this._document.createElement('div'), this._componentFactoryResolver, this._appRef, this._injector);\n        }\n        /** @type {?} */\n        var element = this._template.elementRef.nativeElement;\n        // Because we support opening the same menu from different triggers (which in turn have their\n        // own `OverlayRef` panel), we have to re-insert the host element every time, otherwise we\n        // risk it staying attached to a pane that's no longer in the DOM.\n        (/** @type {?} */ (element.parentNode)).insertBefore(this._outlet.outletElement, element);\n        this._portal.attach(this._outlet, context);\n        this._attached.next();\n    };\n    /**\n     * Detaches the content.\n     * @docs-private\n     */\n    /**\n     * Detaches the content.\n     * \\@docs-private\n     * @return {?}\n     */\n    MatMenuContent.prototype.detach = /**\n     * Detaches the content.\n     * \\@docs-private\n     * @return {?}\n     */\n    function () {\n        if (this._portal.isAttached) {\n            this._portal.detach();\n        }\n    };\n    /**\n     * @return {?}\n     */\n    MatMenuContent.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        if (this._outlet) {\n            this._outlet.dispose();\n        }\n    };\n    MatMenuContent.decorators = [\n        { type: Directive, args: [{\n                    selector: 'ng-template[matMenuContent]'\n                },] },\n    ];\n    /** @nocollapse */\n    MatMenuContent.ctorParameters = function () { return [\n        { type: TemplateRef },\n        { type: ComponentFactoryResolver },\n        { type: ApplicationRef },\n        { type: Injector },\n        { type: ViewContainerRef },\n        { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] }\n    ]; };\n    return MatMenuContent;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Animations used by the mat-menu component.\n * Animation duration and timing values are based on:\n * https://material.io/guidelines/components/menus.html#menus-usage\n * \\@docs-private\n * @type {?}\n */\nvar matMenuAnimations = {\n    /**\n     * This animation controls the menu panel's entry and exit from the page.\n     *\n     * When the menu panel is added to the DOM, it scales in and fades in its border.\n     *\n     * When the menu panel is removed from the DOM, it simply fades out after a brief\n     * delay to display the ripple.\n     */\n    transformMenu: trigger('transformMenu', [\n        state('void', style({\n            opacity: 0,\n            transform: 'scale(0.8)'\n        })),\n        transition('void => enter', group([\n            query('.mat-menu-content', animate('100ms linear', style({ opacity: 1 }))),\n            animate('120ms cubic-bezier(0, 0, 0.2, 1)', style({ transform: 'scale(1)' })),\n        ])),\n        transition('* => void', animate('100ms 25ms linear', style({ opacity: 0 })))\n    ]),\n    /**\n     * This animation fades in the background color and content of the menu panel\n     * after its containing element is scaled in.\n     */\n    fadeInItems: trigger('fadeInItems', [\n        // TODO(crisbeto): this is inside the `transformMenu`\n        // now. Remove next time we do breaking changes.\n        state('showing', style({ opacity: 1 })),\n        transition('void => *', [\n            style({ opacity: 0 }),\n            animate('400ms 100ms cubic-bezier(0.55, 0, 0.55, 0.2)')\n        ])\n    ])\n};\n/**\n * @deprecated\n * \\@breaking-change 8.0.0\n * \\@docs-private\n * @type {?}\n */\nvar fadeInItems = matMenuAnimations.fadeInItems;\n/**\n * @deprecated\n * \\@breaking-change 8.0.0\n * \\@docs-private\n * @type {?}\n */\nvar transformMenu = matMenuAnimations.transformMenu;\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Throws an exception for the case when menu trigger doesn't have a valid mat-menu instance\n * \\@docs-private\n * @return {?}\n */\nfunction throwMatMenuMissingError() {\n    throw Error(\"matMenuTriggerFor: must pass in an mat-menu instance.\\n\\n    Example:\\n      <mat-menu #menu=\\\"matMenu\\\"></mat-menu>\\n      <button [matMenuTriggerFor]=\\\"menu\\\"></button>\");\n}\n/**\n * Throws an exception for the case when menu's x-position value isn't valid.\n * In other words, it doesn't match 'before' or 'after'.\n * \\@docs-private\n * @return {?}\n */\nfunction throwMatMenuInvalidPositionX() {\n    throw Error(\"xPosition value must be either 'before' or after'.\\n      Example: <mat-menu xPosition=\\\"before\\\" #menu=\\\"matMenu\\\"></mat-menu>\");\n}\n/**\n * Throws an exception for the case when menu's y-position value isn't valid.\n * In other words, it doesn't match 'above' or 'below'.\n * \\@docs-private\n * @return {?}\n */\nfunction throwMatMenuInvalidPositionY() {\n    throw Error(\"yPosition value must be either 'above' or below'.\\n      Example: <mat-menu yPosition=\\\"above\\\" #menu=\\\"matMenu\\\"></mat-menu>\");\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Injection token used to provide the parent menu to menu-specific components.\n * \\@docs-private\n * @type {?}\n */\nvar MAT_MENU_PANEL = new InjectionToken('MAT_MENU_PANEL');\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n// Boilerplate for applying mixins to MatMenuItem.\n/**\n * \\@docs-private\n */\nvar  \n// Boilerplate for applying mixins to MatMenuItem.\n/**\n * \\@docs-private\n */\nMatMenuItemBase = /** @class */ (function () {\n    function MatMenuItemBase() {\n    }\n    return MatMenuItemBase;\n}());\n/** @type {?} */\nvar _MatMenuItemMixinBase = mixinDisableRipple(mixinDisabled(MatMenuItemBase));\n/**\n * This directive is intended to be used inside an mat-menu tag.\n * It exists mostly to set the role attribute.\n */\nvar MatMenuItem = /** @class */ (function (_super) {\n    __extends(MatMenuItem, _super);\n    function MatMenuItem(_elementRef, document, _focusMonitor, _parentMenu) {\n        var _this = \n        // @breaking-change 8.0.0 make `_focusMonitor` and `document` required params.\n        _super.call(this) || this;\n        _this._elementRef = _elementRef;\n        _this._focusMonitor = _focusMonitor;\n        _this._parentMenu = _parentMenu;\n        /**\n         * ARIA role for the menu item.\n         */\n        _this.role = 'menuitem';\n        /**\n         * Stream that emits when the menu item is hovered.\n         */\n        _this._hovered = new Subject();\n        /**\n         * Whether the menu item is highlighted.\n         */\n        _this._highlighted = false;\n        /**\n         * Whether the menu item acts as a trigger for a sub-menu.\n         */\n        _this._triggersSubmenu = false;\n        if (_focusMonitor) {\n            // Start monitoring the element so it gets the appropriate focused classes. We want\n            // to show the focus style for menu items only when the focus was not caused by a\n            // mouse or touch interaction.\n            _focusMonitor.monitor(_this._elementRef, false);\n        }\n        if (_parentMenu && _parentMenu.addItem) {\n            _parentMenu.addItem(_this);\n        }\n        _this._document = document;\n        return _this;\n    }\n    /** Focuses the menu item. */\n    /**\n     * Focuses the menu item.\n     * @param {?=} origin\n     * @return {?}\n     */\n    MatMenuItem.prototype.focus = /**\n     * Focuses the menu item.\n     * @param {?=} origin\n     * @return {?}\n     */\n    function (origin) {\n        if (origin === void 0) { origin = 'program'; }\n        if (this._focusMonitor) {\n            this._focusMonitor.focusVia(this._getHostElement(), origin);\n        }\n        else {\n            this._getHostElement().focus();\n        }\n    };\n    /**\n     * @return {?}\n     */\n    MatMenuItem.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        if (this._focusMonitor) {\n            this._focusMonitor.stopMonitoring(this._elementRef);\n        }\n        if (this._parentMenu && this._parentMenu.removeItem) {\n            this._parentMenu.removeItem(this);\n        }\n        this._hovered.complete();\n    };\n    /** Used to set the `tabindex`. */\n    /**\n     * Used to set the `tabindex`.\n     * @return {?}\n     */\n    MatMenuItem.prototype._getTabIndex = /**\n     * Used to set the `tabindex`.\n     * @return {?}\n     */\n    function () {\n        return this.disabled ? '-1' : '0';\n    };\n    /** Returns the host DOM element. */\n    /**\n     * Returns the host DOM element.\n     * @return {?}\n     */\n    MatMenuItem.prototype._getHostElement = /**\n     * Returns the host DOM element.\n     * @return {?}\n     */\n    function () {\n        return this._elementRef.nativeElement;\n    };\n    /** Prevents the default element actions if it is disabled. */\n    /**\n     * Prevents the default element actions if it is disabled.\n     * @param {?} event\n     * @return {?}\n     */\n    MatMenuItem.prototype._checkDisabled = /**\n     * Prevents the default element actions if it is disabled.\n     * @param {?} event\n     * @return {?}\n     */\n    function (event) {\n        if (this.disabled) {\n            event.preventDefault();\n            event.stopPropagation();\n        }\n    };\n    /** Emits to the hover stream. */\n    /**\n     * Emits to the hover stream.\n     * @return {?}\n     */\n    MatMenuItem.prototype._handleMouseEnter = /**\n     * Emits to the hover stream.\n     * @return {?}\n     */\n    function () {\n        this._hovered.next(this);\n    };\n    /** Gets the label to be used when determining whether the option should be focused. */\n    /**\n     * Gets the label to be used when determining whether the option should be focused.\n     * @return {?}\n     */\n    MatMenuItem.prototype.getLabel = /**\n     * Gets the label to be used when determining whether the option should be focused.\n     * @return {?}\n     */\n    function () {\n        /** @type {?} */\n        var element = this._elementRef.nativeElement;\n        /** @type {?} */\n        var textNodeType = this._document ? this._document.TEXT_NODE : 3;\n        /** @type {?} */\n        var output = '';\n        if (element.childNodes) {\n            /** @type {?} */\n            var length_1 = element.childNodes.length;\n            // Go through all the top-level text nodes and extract their text.\n            // We skip anything that's not a text node to prevent the text from\n            // being thrown off by something like an icon.\n            for (var i = 0; i < length_1; i++) {\n                if (element.childNodes[i].nodeType === textNodeType) {\n                    output += element.childNodes[i].textContent;\n                }\n            }\n        }\n        return output.trim();\n    };\n    MatMenuItem.decorators = [\n        { type: Component, args: [{selector: '[mat-menu-item]',\n                    exportAs: 'matMenuItem',\n                    inputs: ['disabled', 'disableRipple'],\n                    host: {\n                        '[attr.role]': 'role',\n                        'class': 'mat-menu-item',\n                        '[class.mat-menu-item-highlighted]': '_highlighted',\n                        '[class.mat-menu-item-submenu-trigger]': '_triggersSubmenu',\n                        '[attr.tabindex]': '_getTabIndex()',\n                        '[attr.aria-disabled]': 'disabled.toString()',\n                        '[attr.disabled]': 'disabled || null',\n                        '(click)': '_checkDisabled($event)',\n                        '(mouseenter)': '_handleMouseEnter()',\n                    },\n                    changeDetection: ChangeDetectionStrategy.OnPush,\n                    encapsulation: ViewEncapsulation.None,\n                    template: \"<ng-content></ng-content><div class=\\\"mat-menu-ripple\\\" matRipple [matRippleDisabled]=\\\"disableRipple || disabled\\\" [matRippleTrigger]=\\\"_getHostElement()\\\"></div>\",\n                },] },\n    ];\n    /** @nocollapse */\n    MatMenuItem.ctorParameters = function () { return [\n        { type: ElementRef },\n        { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },\n        { type: FocusMonitor },\n        { type: undefined, decorators: [{ type: Inject, args: [MAT_MENU_PANEL,] }, { type: Optional }] }\n    ]; };\n    MatMenuItem.propDecorators = {\n        role: [{ type: Input }]\n    };\n    return MatMenuItem;\n}(_MatMenuItemMixinBase));\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Injection token to be used to override the default options for `mat-menu`.\n * @type {?}\n */\nvar MAT_MENU_DEFAULT_OPTIONS = new InjectionToken('mat-menu-default-options', {\n    providedIn: 'root',\n    factory: MAT_MENU_DEFAULT_OPTIONS_FACTORY\n});\n/**\n * \\@docs-private\n * @return {?}\n */\nfunction MAT_MENU_DEFAULT_OPTIONS_FACTORY() {\n    return {\n        overlapTrigger: false,\n        xPosition: 'after',\n        yPosition: 'below',\n        backdropClass: 'cdk-overlay-transparent-backdrop',\n    };\n}\n/**\n * Start elevation for the menu panel.\n * \\@docs-private\n * @type {?}\n */\nvar MAT_MENU_BASE_ELEVATION = 4;\nvar MatMenu = /** @class */ (function () {\n    function MatMenu(_elementRef, _ngZone, _defaultOptions) {\n        this._elementRef = _elementRef;\n        this._ngZone = _ngZone;\n        this._defaultOptions = _defaultOptions;\n        this._xPosition = this._defaultOptions.xPosition;\n        this._yPosition = this._defaultOptions.yPosition;\n        /**\n         * Menu items inside the current menu.\n         */\n        this._items = [];\n        /**\n         * Emits whenever the amount of menu items changes.\n         */\n        this._itemChanges = new Subject();\n        /**\n         * Subscription to tab events on the menu panel\n         */\n        this._tabSubscription = Subscription.EMPTY;\n        /**\n         * Config object to be passed into the menu's ngClass\n         */\n        this._classList = {};\n        /**\n         * Current state of the panel animation.\n         */\n        this._panelAnimationState = 'void';\n        /**\n         * Emits whenever an animation on the menu completes.\n         */\n        this._animationDone = new Subject();\n        /**\n         * Class to be added to the backdrop element.\n         */\n        this.backdropClass = this._defaultOptions.backdropClass;\n        this._overlapTrigger = this._defaultOptions.overlapTrigger;\n        this._hasBackdrop = this._defaultOptions.hasBackdrop;\n        /**\n         * Event emitted when the menu is closed.\n         */\n        this.closed = new EventEmitter();\n        /**\n         * Event emitted when the menu is closed.\n         * @deprecated Switch to `closed` instead\n         * \\@breaking-change 8.0.0\n         */\n        this.close = this.closed;\n    }\n    Object.defineProperty(MatMenu.prototype, \"xPosition\", {\n        /** Position of the menu in the X axis. */\n        get: /**\n         * Position of the menu in the X axis.\n         * @return {?}\n         */\n        function () { return this._xPosition; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */\n        function (value) {\n            if (value !== 'before' && value !== 'after') {\n                throwMatMenuInvalidPositionX();\n            }\n            this._xPosition = value;\n            this.setPositionClasses();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatMenu.prototype, \"yPosition\", {\n        /** Position of the menu in the Y axis. */\n        get: /**\n         * Position of the menu in the Y axis.\n         * @return {?}\n         */\n        function () { return this._yPosition; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */\n        function (value) {\n            if (value !== 'above' && value !== 'below') {\n                throwMatMenuInvalidPositionY();\n            }\n            this._yPosition = value;\n            this.setPositionClasses();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatMenu.prototype, \"overlapTrigger\", {\n        /** Whether the menu should overlap its trigger. */\n        get: /**\n         * Whether the menu should overlap its trigger.\n         * @return {?}\n         */\n        function () { return this._overlapTrigger; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */\n        function (value) {\n            this._overlapTrigger = coerceBooleanProperty(value);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatMenu.prototype, \"hasBackdrop\", {\n        /** Whether the menu has a backdrop. */\n        get: /**\n         * Whether the menu has a backdrop.\n         * @return {?}\n         */\n        function () { return this._hasBackdrop; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */\n        function (value) {\n            this._hasBackdrop = coerceBooleanProperty(value);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatMenu.prototype, \"panelClass\", {\n        /**\n         * This method takes classes set on the host mat-menu element and applies them on the\n         * menu template that displays in the overlay container.  Otherwise, it's difficult\n         * to style the containing menu from outside the component.\n         * @param classes list of class names\n         */\n        set: /**\n         * This method takes classes set on the host mat-menu element and applies them on the\n         * menu template that displays in the overlay container.  Otherwise, it's difficult\n         * to style the containing menu from outside the component.\n         * @param {?} classes list of class names\n         * @return {?}\n         */\n        function (classes) {\n            var _this = this;\n            /** @type {?} */\n            var previousPanelClass = this._previousPanelClass;\n            if (previousPanelClass && previousPanelClass.length) {\n                previousPanelClass.split(' ').forEach(function (className) {\n                    _this._classList[className] = false;\n                });\n            }\n            this._previousPanelClass = classes;\n            if (classes && classes.length) {\n                classes.split(' ').forEach(function (className) {\n                    _this._classList[className] = true;\n                });\n                this._elementRef.nativeElement.className = '';\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatMenu.prototype, \"classList\", {\n        /**\n         * This method takes classes set on the host mat-menu element and applies them on the\n         * menu template that displays in the overlay container.  Otherwise, it's difficult\n         * to style the containing menu from outside the component.\n         * @deprecated Use `panelClass` instead.\n         * @breaking-change 8.0.0\n         */\n        get: /**\n         * This method takes classes set on the host mat-menu element and applies them on the\n         * menu template that displays in the overlay container.  Otherwise, it's difficult\n         * to style the containing menu from outside the component.\n         * @deprecated Use `panelClass` instead.\n         * \\@breaking-change 8.0.0\n         * @return {?}\n         */\n        function () { return this.panelClass; },\n        set: /**\n         * @param {?} classes\n         * @return {?}\n         */\n        function (classes) { this.panelClass = classes; },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    MatMenu.prototype.ngOnInit = /**\n     * @return {?}\n     */\n    function () {\n        this.setPositionClasses();\n    };\n    /**\n     * @return {?}\n     */\n    MatMenu.prototype.ngAfterContentInit = /**\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        this._keyManager = new FocusKeyManager(this._items).withWrap().withTypeAhead();\n        this._tabSubscription = this._keyManager.tabOut.subscribe(function () { return _this.closed.emit('tab'); });\n    };\n    /**\n     * @return {?}\n     */\n    MatMenu.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        this._tabSubscription.unsubscribe();\n        this.closed.complete();\n    };\n    /** Stream that emits whenever the hovered menu item changes. */\n    /**\n     * Stream that emits whenever the hovered menu item changes.\n     * @return {?}\n     */\n    MatMenu.prototype._hovered = /**\n     * Stream that emits whenever the hovered menu item changes.\n     * @return {?}\n     */\n    function () {\n        return this._itemChanges.pipe(startWith(this._items), switchMap(function (items) { return merge.apply(void 0, items.map(function (item) { return item._hovered; })); }));\n    };\n    /** Handle a keyboard event from the menu, delegating to the appropriate action. */\n    /**\n     * Handle a keyboard event from the menu, delegating to the appropriate action.\n     * @param {?} event\n     * @return {?}\n     */\n    MatMenu.prototype._handleKeydown = /**\n     * Handle a keyboard event from the menu, delegating to the appropriate action.\n     * @param {?} event\n     * @return {?}\n     */\n    function (event) {\n        /** @type {?} */\n        var keyCode = event.keyCode;\n        /** @type {?} */\n        var manager = this._keyManager;\n        switch (keyCode) {\n            case ESCAPE:\n                this.closed.emit('keydown');\n                break;\n            case LEFT_ARROW:\n                if (this.parentMenu && this.direction === 'ltr') {\n                    this.closed.emit('keydown');\n                }\n                break;\n            case RIGHT_ARROW:\n                if (this.parentMenu && this.direction === 'rtl') {\n                    this.closed.emit('keydown');\n                }\n                break;\n            case HOME:\n            case END:\n                if (!hasModifierKey(event)) {\n                    keyCode === HOME ? manager.setFirstItemActive() : manager.setLastItemActive();\n                    event.preventDefault();\n                }\n                break;\n            default:\n                if (keyCode === UP_ARROW || keyCode === DOWN_ARROW) {\n                    manager.setFocusOrigin('keyboard');\n                }\n                manager.onKeydown(event);\n        }\n    };\n    /**\n     * Focus the first item in the menu.\n     * @param origin Action from which the focus originated. Used to set the correct styling.\n     */\n    /**\n     * Focus the first item in the menu.\n     * @param {?=} origin Action from which the focus originated. Used to set the correct styling.\n     * @return {?}\n     */\n    MatMenu.prototype.focusFirstItem = /**\n     * Focus the first item in the menu.\n     * @param {?=} origin Action from which the focus originated. Used to set the correct styling.\n     * @return {?}\n     */\n    function (origin) {\n        var _this = this;\n        if (origin === void 0) { origin = 'program'; }\n        // When the content is rendered lazily, it takes a bit before the items are inside the DOM.\n        if (this.lazyContent) {\n            this._ngZone.onStable.asObservable()\n                .pipe(take(1))\n                .subscribe(function () { return _this._keyManager.setFocusOrigin(origin).setFirstItemActive(); });\n        }\n        else {\n            this._keyManager.setFocusOrigin(origin).setFirstItemActive();\n        }\n    };\n    /**\n     * Resets the active item in the menu. This is used when the menu is opened, allowing\n     * the user to start from the first option when pressing the down arrow.\n     */\n    /**\n     * Resets the active item in the menu. This is used when the menu is opened, allowing\n     * the user to start from the first option when pressing the down arrow.\n     * @return {?}\n     */\n    MatMenu.prototype.resetActiveItem = /**\n     * Resets the active item in the menu. This is used when the menu is opened, allowing\n     * the user to start from the first option when pressing the down arrow.\n     * @return {?}\n     */\n    function () {\n        this._keyManager.setActiveItem(-1);\n    };\n    /**\n     * Sets the menu panel elevation.\n     * @param depth Number of parent menus that come before the menu.\n     */\n    /**\n     * Sets the menu panel elevation.\n     * @param {?} depth Number of parent menus that come before the menu.\n     * @return {?}\n     */\n    MatMenu.prototype.setElevation = /**\n     * Sets the menu panel elevation.\n     * @param {?} depth Number of parent menus that come before the menu.\n     * @return {?}\n     */\n    function (depth) {\n        // The elevation starts at the base and increases by one for each level.\n        /** @type {?} */\n        var newElevation = \"mat-elevation-z\" + (MAT_MENU_BASE_ELEVATION + depth);\n        /** @type {?} */\n        var customElevation = Object.keys(this._classList).find(function (c) { return c.startsWith('mat-elevation-z'); });\n        if (!customElevation || customElevation === this._previousElevation) {\n            if (this._previousElevation) {\n                this._classList[this._previousElevation] = false;\n            }\n            this._classList[newElevation] = true;\n            this._previousElevation = newElevation;\n        }\n    };\n    /**\n     * Registers a menu item with the menu.\n     * @docs-private\n     */\n    /**\n     * Registers a menu item with the menu.\n     * \\@docs-private\n     * @param {?} item\n     * @return {?}\n     */\n    MatMenu.prototype.addItem = /**\n     * Registers a menu item with the menu.\n     * \\@docs-private\n     * @param {?} item\n     * @return {?}\n     */\n    function (item) {\n        // We register the items through this method, rather than picking them up through\n        // `ContentChildren`, because we need the items to be picked up by their closest\n        // `mat-menu` ancestor. If we used `@ContentChildren(MatMenuItem, {descendants: true})`,\n        // all descendant items will bleed into the top-level menu in the case where the consumer\n        // has `mat-menu` instances nested inside each other.\n        if (this._items.indexOf(item) === -1) {\n            this._items.push(item);\n            this._itemChanges.next(this._items);\n        }\n    };\n    /**\n     * Removes an item from the menu.\n     * @docs-private\n     */\n    /**\n     * Removes an item from the menu.\n     * \\@docs-private\n     * @param {?} item\n     * @return {?}\n     */\n    MatMenu.prototype.removeItem = /**\n     * Removes an item from the menu.\n     * \\@docs-private\n     * @param {?} item\n     * @return {?}\n     */\n    function (item) {\n        /** @type {?} */\n        var index = this._items.indexOf(item);\n        if (this._items.indexOf(item) > -1) {\n            this._items.splice(index, 1);\n            this._itemChanges.next(this._items);\n        }\n    };\n    /**\n     * Adds classes to the menu panel based on its position. Can be used by\n     * consumers to add specific styling based on the position.\n     * @param posX Position of the menu along the x axis.\n     * @param posY Position of the menu along the y axis.\n     * @docs-private\n     */\n    /**\n     * Adds classes to the menu panel based on its position. Can be used by\n     * consumers to add specific styling based on the position.\n     * \\@docs-private\n     * @param {?=} posX Position of the menu along the x axis.\n     * @param {?=} posY Position of the menu along the y axis.\n     * @return {?}\n     */\n    MatMenu.prototype.setPositionClasses = /**\n     * Adds classes to the menu panel based on its position. Can be used by\n     * consumers to add specific styling based on the position.\n     * \\@docs-private\n     * @param {?=} posX Position of the menu along the x axis.\n     * @param {?=} posY Position of the menu along the y axis.\n     * @return {?}\n     */\n    function (posX, posY) {\n        if (posX === void 0) { posX = this.xPosition; }\n        if (posY === void 0) { posY = this.yPosition; }\n        /** @type {?} */\n        var classes = this._classList;\n        classes['mat-menu-before'] = posX === 'before';\n        classes['mat-menu-after'] = posX === 'after';\n        classes['mat-menu-above'] = posY === 'above';\n        classes['mat-menu-below'] = posY === 'below';\n    };\n    /** Starts the enter animation. */\n    /**\n     * Starts the enter animation.\n     * @return {?}\n     */\n    MatMenu.prototype._startAnimation = /**\n     * Starts the enter animation.\n     * @return {?}\n     */\n    function () {\n        // @breaking-change 8.0.0 Combine with _resetAnimation.\n        this._panelAnimationState = 'enter';\n    };\n    /** Resets the panel animation to its initial state. */\n    /**\n     * Resets the panel animation to its initial state.\n     * @return {?}\n     */\n    MatMenu.prototype._resetAnimation = /**\n     * Resets the panel animation to its initial state.\n     * @return {?}\n     */\n    function () {\n        // @breaking-change 8.0.0 Combine with _startAnimation.\n        this._panelAnimationState = 'void';\n    };\n    /** Callback that is invoked when the panel animation completes. */\n    /**\n     * Callback that is invoked when the panel animation completes.\n     * @param {?} event\n     * @return {?}\n     */\n    MatMenu.prototype._onAnimationDone = /**\n     * Callback that is invoked when the panel animation completes.\n     * @param {?} event\n     * @return {?}\n     */\n    function (event) {\n        this._animationDone.next(event);\n        this._isAnimating = false;\n    };\n    /**\n     * @param {?} event\n     * @return {?}\n     */\n    MatMenu.prototype._onAnimationStart = /**\n     * @param {?} event\n     * @return {?}\n     */\n    function (event) {\n        this._isAnimating = true;\n        // Scroll the content element to the top as soon as the animation starts. This is necessary,\n        // because we move focus to the first item while it's still being animated, which can throw\n        // the browser off when it determines the scroll position. Alternatively we can move focus\n        // when the animation is done, however moving focus asynchronously will interrupt screen\n        // readers which are in the process of reading out the menu already. We take the `element`\n        // from the `event` since we can't use a `ViewChild` to access the pane.\n        if (event.toState === 'enter' && this._keyManager.activeItemIndex === 0) {\n            event.element.scrollTop = 0;\n        }\n    };\n    MatMenu.decorators = [\n        { type: Component, args: [{selector: 'mat-menu',\n                    template: \"<ng-template><div class=\\\"mat-menu-panel\\\" [ngClass]=\\\"_classList\\\" (keydown)=\\\"_handleKeydown($event)\\\" (click)=\\\"closed.emit('click')\\\" [@transformMenu]=\\\"_panelAnimationState\\\" (@transformMenu.start)=\\\"_onAnimationStart($event)\\\" (@transformMenu.done)=\\\"_onAnimationDone($event)\\\" tabindex=\\\"-1\\\" role=\\\"menu\\\"><div class=\\\"mat-menu-content\\\"><ng-content></ng-content></div></div></ng-template>\",\n                    styles: [\".mat-menu-panel{min-width:112px;max-width:280px;overflow:auto;-webkit-overflow-scrolling:touch;max-height:calc(100vh - 48px);border-radius:4px;outline:0}.mat-menu-panel.ng-animating{pointer-events:none}@media (-ms-high-contrast:active){.mat-menu-panel{outline:solid 1px}}.mat-menu-content:not(:empty){padding-top:8px;padding-bottom:8px}.mat-menu-item{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:0;border:none;-webkit-tap-highlight-color:transparent;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;display:block;line-height:48px;height:48px;padding:0 16px;text-align:left;text-decoration:none;max-width:100%;position:relative}.mat-menu-item::-moz-focus-inner{border:0}.mat-menu-item[disabled]{cursor:default}[dir=rtl] .mat-menu-item{text-align:right}.mat-menu-item .mat-icon{margin-right:16px;vertical-align:middle}.mat-menu-item .mat-icon svg{vertical-align:top}[dir=rtl] .mat-menu-item .mat-icon{margin-left:16px;margin-right:0}@media (-ms-high-contrast:active){.mat-menu-item-highlighted,.mat-menu-item.cdk-keyboard-focused,.mat-menu-item.cdk-program-focused{outline:dotted 1px}}.mat-menu-item-submenu-trigger{padding-right:32px}.mat-menu-item-submenu-trigger::after{width:0;height:0;border-style:solid;border-width:5px 0 5px 5px;border-color:transparent transparent transparent currentColor;content:'';display:inline-block;position:absolute;top:50%;right:16px;transform:translateY(-50%)}[dir=rtl] .mat-menu-item-submenu-trigger{padding-right:16px;padding-left:32px}[dir=rtl] .mat-menu-item-submenu-trigger::after{right:auto;left:16px;transform:rotateY(180deg) translateY(-50%)}button.mat-menu-item{width:100%}.mat-menu-item .mat-menu-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none}\"],\n                    changeDetection: ChangeDetectionStrategy.OnPush,\n                    encapsulation: ViewEncapsulation.None,\n                    exportAs: 'matMenu',\n                    animations: [\n                        matMenuAnimations.transformMenu,\n                        matMenuAnimations.fadeInItems\n                    ],\n                    providers: [\n                        { provide: MAT_MENU_PANEL, useExisting: MatMenu }\n                    ]\n                },] },\n    ];\n    /** @nocollapse */\n    MatMenu.ctorParameters = function () { return [\n        { type: ElementRef },\n        { type: NgZone },\n        { type: undefined, decorators: [{ type: Inject, args: [MAT_MENU_DEFAULT_OPTIONS,] }] }\n    ]; };\n    MatMenu.propDecorators = {\n        backdropClass: [{ type: Input }],\n        xPosition: [{ type: Input }],\n        yPosition: [{ type: Input }],\n        templateRef: [{ type: ViewChild, args: [TemplateRef, { static: false },] }],\n        items: [{ type: ContentChildren, args: [MatMenuItem,] }],\n        lazyContent: [{ type: ContentChild, args: [MatMenuContent, { static: false },] }],\n        overlapTrigger: [{ type: Input }],\n        hasBackdrop: [{ type: Input }],\n        panelClass: [{ type: Input, args: ['class',] }],\n        classList: [{ type: Input }],\n        closed: [{ type: Output }],\n        close: [{ type: Output }]\n    };\n    return MatMenu;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Injection token that determines the scroll handling while the menu is open.\n * @type {?}\n */\nvar MAT_MENU_SCROLL_STRATEGY = new InjectionToken('mat-menu-scroll-strategy');\n/**\n * \\@docs-private\n * @param {?} overlay\n * @return {?}\n */\nfunction MAT_MENU_SCROLL_STRATEGY_FACTORY(overlay) {\n    return function () { return overlay.scrollStrategies.reposition(); };\n}\n/**\n * \\@docs-private\n * @type {?}\n */\nvar MAT_MENU_SCROLL_STRATEGY_FACTORY_PROVIDER = {\n    provide: MAT_MENU_SCROLL_STRATEGY,\n    deps: [Overlay],\n    useFactory: MAT_MENU_SCROLL_STRATEGY_FACTORY,\n};\n/**\n * Default top padding of the menu panel.\n * @type {?}\n */\nvar MENU_PANEL_TOP_PADDING = 8;\n/**\n * Options for binding a passive event listener.\n * @type {?}\n */\nvar passiveEventListenerOptions = normalizePassiveListenerOptions({ passive: true });\n// TODO(andrewseguin): Remove the kebab versions in favor of camelCased attribute selectors\n/**\n * This directive is intended to be used in conjunction with an mat-menu tag.  It is\n * responsible for toggling the display of the provided menu instance.\n */\nvar MatMenuTrigger = /** @class */ (function () {\n    function MatMenuTrigger(_overlay, _element, _viewContainerRef, scrollStrategy, _parentMenu, _menuItemInstance, _dir, _focusMonitor) {\n        var _this = this;\n        this._overlay = _overlay;\n        this._element = _element;\n        this._viewContainerRef = _viewContainerRef;\n        this._parentMenu = _parentMenu;\n        this._menuItemInstance = _menuItemInstance;\n        this._dir = _dir;\n        this._focusMonitor = _focusMonitor;\n        this._overlayRef = null;\n        this._menuOpen = false;\n        this._closingActionsSubscription = Subscription.EMPTY;\n        this._hoverSubscription = Subscription.EMPTY;\n        this._menuCloseSubscription = Subscription.EMPTY;\n        /**\n         * Handles touch start events on the trigger.\n         * Needs to be an arrow function so we can easily use addEventListener and removeEventListener.\n         */\n        this._handleTouchStart = function () { return _this._openedBy = 'touch'; };\n        // Tracking input type is necessary so it's possible to only auto-focus\n        // the first item of the list when the menu is opened via the keyboard\n        this._openedBy = null;\n        /**\n         * Whether focus should be restored when the menu is closed.\n         * Note that disabling this option can have accessibility implications\n         * and it's up to you to manage focus, if you decide to turn it off.\n         */\n        this.restoreFocus = true;\n        /**\n         * Event emitted when the associated menu is opened.\n         */\n        this.menuOpened = new EventEmitter();\n        /**\n         * Event emitted when the associated menu is opened.\n         * @deprecated Switch to `menuOpened` instead\n         * \\@breaking-change 8.0.0\n         */\n        // tslint:disable-next-line:no-output-on-prefix\n        this.onMenuOpen = this.menuOpened;\n        /**\n         * Event emitted when the associated menu is closed.\n         */\n        this.menuClosed = new EventEmitter();\n        /**\n         * Event emitted when the associated menu is closed.\n         * @deprecated Switch to `menuClosed` instead\n         * \\@breaking-change 8.0.0\n         */\n        // tslint:disable-next-line:no-output-on-prefix\n        this.onMenuClose = this.menuClosed;\n        _element.nativeElement.addEventListener('touchstart', this._handleTouchStart, passiveEventListenerOptions);\n        if (_menuItemInstance) {\n            _menuItemInstance._triggersSubmenu = this.triggersSubmenu();\n        }\n        this._scrollStrategy = scrollStrategy;\n    }\n    Object.defineProperty(MatMenuTrigger.prototype, \"_deprecatedMatMenuTriggerFor\", {\n        /**\n         * @deprecated\n         * @breaking-change 8.0.0\n         */\n        get: /**\n         * @deprecated\n         * \\@breaking-change 8.0.0\n         * @return {?}\n         */\n        function () { return this.menu; },\n        set: /**\n         * @param {?} v\n         * @return {?}\n         */\n        function (v) {\n            this.menu = v;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatMenuTrigger.prototype, \"menu\", {\n        /** References the menu instance that the trigger is associated with. */\n        get: /**\n         * References the menu instance that the trigger is associated with.\n         * @return {?}\n         */\n        function () { return this._menu; },\n        set: /**\n         * @param {?} menu\n         * @return {?}\n         */\n        function (menu) {\n            var _this = this;\n            if (menu === this._menu) {\n                return;\n            }\n            this._menu = menu;\n            this._menuCloseSubscription.unsubscribe();\n            if (menu) {\n                this._menuCloseSubscription = menu.close.asObservable().subscribe(function (reason) {\n                    _this._destroyMenu();\n                    // If a click closed the menu, we should close the entire chain of nested menus.\n                    if ((reason === 'click' || reason === 'tab') && _this._parentMenu) {\n                        _this._parentMenu.closed.emit(reason);\n                    }\n                });\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    MatMenuTrigger.prototype.ngAfterContentInit = /**\n     * @return {?}\n     */\n    function () {\n        this._checkMenu();\n        this._handleHover();\n    };\n    /**\n     * @return {?}\n     */\n    MatMenuTrigger.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        if (this._overlayRef) {\n            this._overlayRef.dispose();\n            this._overlayRef = null;\n        }\n        this._element.nativeElement.removeEventListener('touchstart', this._handleTouchStart, passiveEventListenerOptions);\n        this._cleanUpSubscriptions();\n        this._closingActionsSubscription.unsubscribe();\n    };\n    Object.defineProperty(MatMenuTrigger.prototype, \"menuOpen\", {\n        /** Whether the menu is open. */\n        get: /**\n         * Whether the menu is open.\n         * @return {?}\n         */\n        function () {\n            return this._menuOpen;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatMenuTrigger.prototype, \"dir\", {\n        /** The text direction of the containing app. */\n        get: /**\n         * The text direction of the containing app.\n         * @return {?}\n         */\n        function () {\n            return this._dir && this._dir.value === 'rtl' ? 'rtl' : 'ltr';\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /** Whether the menu triggers a sub-menu or a top-level one. */\n    /**\n     * Whether the menu triggers a sub-menu or a top-level one.\n     * @return {?}\n     */\n    MatMenuTrigger.prototype.triggersSubmenu = /**\n     * Whether the menu triggers a sub-menu or a top-level one.\n     * @return {?}\n     */\n    function () {\n        return !!(this._menuItemInstance && this._parentMenu);\n    };\n    /** Toggles the menu between the open and closed states. */\n    /**\n     * Toggles the menu between the open and closed states.\n     * @return {?}\n     */\n    MatMenuTrigger.prototype.toggleMenu = /**\n     * Toggles the menu between the open and closed states.\n     * @return {?}\n     */\n    function () {\n        return this._menuOpen ? this.closeMenu() : this.openMenu();\n    };\n    /** Opens the menu. */\n    /**\n     * Opens the menu.\n     * @return {?}\n     */\n    MatMenuTrigger.prototype.openMenu = /**\n     * Opens the menu.\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        if (this._menuOpen) {\n            return;\n        }\n        this._checkMenu();\n        /** @type {?} */\n        var overlayRef = this._createOverlay();\n        /** @type {?} */\n        var overlayConfig = overlayRef.getConfig();\n        this._setPosition((/** @type {?} */ (overlayConfig.positionStrategy)));\n        overlayConfig.hasBackdrop = this.menu.hasBackdrop == null ? !this.triggersSubmenu() :\n            this.menu.hasBackdrop;\n        overlayRef.attach(this._getPortal());\n        if (this.menu.lazyContent) {\n            this.menu.lazyContent.attach(this.menuData);\n        }\n        this._closingActionsSubscription = this._menuClosingActions().subscribe(function () { return _this.closeMenu(); });\n        this._initMenu();\n        if (this.menu instanceof MatMenu) {\n            this.menu._startAnimation();\n        }\n    };\n    /** Closes the menu. */\n    /**\n     * Closes the menu.\n     * @return {?}\n     */\n    MatMenuTrigger.prototype.closeMenu = /**\n     * Closes the menu.\n     * @return {?}\n     */\n    function () {\n        this.menu.close.emit();\n    };\n    /**\n     * Focuses the menu trigger.\n     * @param origin Source of the menu trigger's focus.\n     */\n    /**\n     * Focuses the menu trigger.\n     * @param {?=} origin Source of the menu trigger's focus.\n     * @return {?}\n     */\n    MatMenuTrigger.prototype.focus = /**\n     * Focuses the menu trigger.\n     * @param {?=} origin Source of the menu trigger's focus.\n     * @return {?}\n     */\n    function (origin) {\n        if (origin === void 0) { origin = 'program'; }\n        if (this._focusMonitor) {\n            this._focusMonitor.focusVia(this._element, origin);\n        }\n        else {\n            this._element.nativeElement.focus();\n        }\n    };\n    /** Closes the menu and does the necessary cleanup. */\n    /**\n     * Closes the menu and does the necessary cleanup.\n     * @private\n     * @return {?}\n     */\n    MatMenuTrigger.prototype._destroyMenu = /**\n     * Closes the menu and does the necessary cleanup.\n     * @private\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        if (!this._overlayRef || !this.menuOpen) {\n            return;\n        }\n        /** @type {?} */\n        var menu = this.menu;\n        this._closingActionsSubscription.unsubscribe();\n        this._overlayRef.detach();\n        if (menu instanceof MatMenu) {\n            menu._resetAnimation();\n            if (menu.lazyContent) {\n                // Wait for the exit animation to finish before detaching the content.\n                menu._animationDone\n                    .pipe(filter(function (event) { return event.toState === 'void'; }), take(1), \n                // Interrupt if the content got re-attached.\n                takeUntil(menu.lazyContent._attached))\n                    .subscribe(function () { return (/** @type {?} */ (menu.lazyContent)).detach(); }, undefined, function () {\n                    // No matter whether the content got re-attached, reset the menu.\n                    _this._resetMenu();\n                });\n            }\n            else {\n                this._resetMenu();\n            }\n        }\n        else {\n            this._resetMenu();\n            if (menu.lazyContent) {\n                menu.lazyContent.detach();\n            }\n        }\n    };\n    /**\n     * This method sets the menu state to open and focuses the first item if\n     * the menu was opened via the keyboard.\n     */\n    /**\n     * This method sets the menu state to open and focuses the first item if\n     * the menu was opened via the keyboard.\n     * @private\n     * @return {?}\n     */\n    MatMenuTrigger.prototype._initMenu = /**\n     * This method sets the menu state to open and focuses the first item if\n     * the menu was opened via the keyboard.\n     * @private\n     * @return {?}\n     */\n    function () {\n        this.menu.parentMenu = this.triggersSubmenu() ? this._parentMenu : undefined;\n        this.menu.direction = this.dir;\n        this._setMenuElevation();\n        this._setIsMenuOpen(true);\n        this.menu.focusFirstItem(this._openedBy || 'program');\n    };\n    /** Updates the menu elevation based on the amount of parent menus that it has. */\n    /**\n     * Updates the menu elevation based on the amount of parent menus that it has.\n     * @private\n     * @return {?}\n     */\n    MatMenuTrigger.prototype._setMenuElevation = /**\n     * Updates the menu elevation based on the amount of parent menus that it has.\n     * @private\n     * @return {?}\n     */\n    function () {\n        if (this.menu.setElevation) {\n            /** @type {?} */\n            var depth = 0;\n            /** @type {?} */\n            var parentMenu = this.menu.parentMenu;\n            while (parentMenu) {\n                depth++;\n                parentMenu = parentMenu.parentMenu;\n            }\n            this.menu.setElevation(depth);\n        }\n    };\n    /**\n     * This method resets the menu when it's closed, most importantly restoring\n     * focus to the menu trigger if the menu was opened via the keyboard.\n     */\n    /**\n     * This method resets the menu when it's closed, most importantly restoring\n     * focus to the menu trigger if the menu was opened via the keyboard.\n     * @private\n     * @return {?}\n     */\n    MatMenuTrigger.prototype._resetMenu = /**\n     * This method resets the menu when it's closed, most importantly restoring\n     * focus to the menu trigger if the menu was opened via the keyboard.\n     * @private\n     * @return {?}\n     */\n    function () {\n        this._setIsMenuOpen(false);\n        // We should reset focus if the user is navigating using a keyboard or\n        // if we have a top-level trigger which might cause focus to be lost\n        // when clicking on the backdrop.\n        if (this.restoreFocus) {\n            if (!this._openedBy) {\n                // Note that the focus style will show up both for `program` and\n                // `keyboard` so we don't have to specify which one it is.\n                this.focus();\n            }\n            else if (!this.triggersSubmenu()) {\n                this.focus(this._openedBy);\n            }\n        }\n        this._openedBy = null;\n    };\n    // set state rather than toggle to support triggers sharing a menu\n    // set state rather than toggle to support triggers sharing a menu\n    /**\n     * @private\n     * @param {?} isOpen\n     * @return {?}\n     */\n    MatMenuTrigger.prototype._setIsMenuOpen = \n    // set state rather than toggle to support triggers sharing a menu\n    /**\n     * @private\n     * @param {?} isOpen\n     * @return {?}\n     */\n    function (isOpen) {\n        this._menuOpen = isOpen;\n        this._menuOpen ? this.menuOpened.emit() : this.menuClosed.emit();\n        if (this.triggersSubmenu()) {\n            this._menuItemInstance._highlighted = isOpen;\n        }\n    };\n    /**\n     * This method checks that a valid instance of MatMenu has been passed into\n     * matMenuTriggerFor. If not, an exception is thrown.\n     */\n    /**\n     * This method checks that a valid instance of MatMenu has been passed into\n     * matMenuTriggerFor. If not, an exception is thrown.\n     * @private\n     * @return {?}\n     */\n    MatMenuTrigger.prototype._checkMenu = /**\n     * This method checks that a valid instance of MatMenu has been passed into\n     * matMenuTriggerFor. If not, an exception is thrown.\n     * @private\n     * @return {?}\n     */\n    function () {\n        if (!this.menu) {\n            throwMatMenuMissingError();\n        }\n    };\n    /**\n     * This method creates the overlay from the provided menu's template and saves its\n     * OverlayRef so that it can be attached to the DOM when openMenu is called.\n     */\n    /**\n     * This method creates the overlay from the provided menu's template and saves its\n     * OverlayRef so that it can be attached to the DOM when openMenu is called.\n     * @private\n     * @return {?}\n     */\n    MatMenuTrigger.prototype._createOverlay = /**\n     * This method creates the overlay from the provided menu's template and saves its\n     * OverlayRef so that it can be attached to the DOM when openMenu is called.\n     * @private\n     * @return {?}\n     */\n    function () {\n        if (!this._overlayRef) {\n            /** @type {?} */\n            var config = this._getOverlayConfig();\n            this._subscribeToPositions((/** @type {?} */ (config.positionStrategy)));\n            this._overlayRef = this._overlay.create(config);\n            // Consume the `keydownEvents` in order to prevent them from going to another overlay.\n            // Ideally we'd also have our keyboard event logic in here, however doing so will\n            // break anybody that may have implemented the `MatMenuPanel` themselves.\n            this._overlayRef.keydownEvents().subscribe();\n        }\n        return this._overlayRef;\n    };\n    /**\n     * This method builds the configuration object needed to create the overlay, the OverlayState.\n     * @returns OverlayConfig\n     */\n    /**\n     * This method builds the configuration object needed to create the overlay, the OverlayState.\n     * @private\n     * @return {?} OverlayConfig\n     */\n    MatMenuTrigger.prototype._getOverlayConfig = /**\n     * This method builds the configuration object needed to create the overlay, the OverlayState.\n     * @private\n     * @return {?} OverlayConfig\n     */\n    function () {\n        return new OverlayConfig({\n            positionStrategy: this._overlay.position()\n                .flexibleConnectedTo(this._element)\n                .withLockedPosition()\n                .withTransformOriginOn('.mat-menu-panel'),\n            backdropClass: this.menu.backdropClass || 'cdk-overlay-transparent-backdrop',\n            scrollStrategy: this._scrollStrategy(),\n            direction: this._dir\n        });\n    };\n    /**\n     * Listens to changes in the position of the overlay and sets the correct classes\n     * on the menu based on the new position. This ensures the animation origin is always\n     * correct, even if a fallback position is used for the overlay.\n     */\n    /**\n     * Listens to changes in the position of the overlay and sets the correct classes\n     * on the menu based on the new position. This ensures the animation origin is always\n     * correct, even if a fallback position is used for the overlay.\n     * @private\n     * @param {?} position\n     * @return {?}\n     */\n    MatMenuTrigger.prototype._subscribeToPositions = /**\n     * Listens to changes in the position of the overlay and sets the correct classes\n     * on the menu based on the new position. This ensures the animation origin is always\n     * correct, even if a fallback position is used for the overlay.\n     * @private\n     * @param {?} position\n     * @return {?}\n     */\n    function (position) {\n        var _this = this;\n        if (this.menu.setPositionClasses) {\n            position.positionChanges.subscribe(function (change) {\n                /** @type {?} */\n                var posX = change.connectionPair.overlayX === 'start' ? 'after' : 'before';\n                /** @type {?} */\n                var posY = change.connectionPair.overlayY === 'top' ? 'below' : 'above';\n                (/** @type {?} */ (_this.menu.setPositionClasses))(posX, posY);\n            });\n        }\n    };\n    /**\n     * Sets the appropriate positions on a position strategy\n     * so the overlay connects with the trigger correctly.\n     * @param positionStrategy Strategy whose position to update.\n     */\n    /**\n     * Sets the appropriate positions on a position strategy\n     * so the overlay connects with the trigger correctly.\n     * @private\n     * @param {?} positionStrategy Strategy whose position to update.\n     * @return {?}\n     */\n    MatMenuTrigger.prototype._setPosition = /**\n     * Sets the appropriate positions on a position strategy\n     * so the overlay connects with the trigger correctly.\n     * @private\n     * @param {?} positionStrategy Strategy whose position to update.\n     * @return {?}\n     */\n    function (positionStrategy) {\n        var _a = this.menu.xPosition === 'before' ? ['end', 'start'] : ['start', 'end'], originX = _a[0], originFallbackX = _a[1];\n        var _b = this.menu.yPosition === 'above' ? ['bottom', 'top'] : ['top', 'bottom'], overlayY = _b[0], overlayFallbackY = _b[1];\n        var _c = [overlayY, overlayFallbackY], originY = _c[0], originFallbackY = _c[1];\n        var _d = [originX, originFallbackX], overlayX = _d[0], overlayFallbackX = _d[1];\n        /** @type {?} */\n        var offsetY = 0;\n        if (this.triggersSubmenu()) {\n            // When the menu is a sub-menu, it should always align itself\n            // to the edges of the trigger, instead of overlapping it.\n            overlayFallbackX = originX = this.menu.xPosition === 'before' ? 'start' : 'end';\n            originFallbackX = overlayX = originX === 'end' ? 'start' : 'end';\n            offsetY = overlayY === 'bottom' ? MENU_PANEL_TOP_PADDING : -MENU_PANEL_TOP_PADDING;\n        }\n        else if (!this.menu.overlapTrigger) {\n            originY = overlayY === 'top' ? 'bottom' : 'top';\n            originFallbackY = overlayFallbackY === 'top' ? 'bottom' : 'top';\n        }\n        positionStrategy.withPositions([\n            { originX: originX, originY: originY, overlayX: overlayX, overlayY: overlayY, offsetY: offsetY },\n            { originX: originFallbackX, originY: originY, overlayX: overlayFallbackX, overlayY: overlayY, offsetY: offsetY },\n            {\n                originX: originX,\n                originY: originFallbackY,\n                overlayX: overlayX,\n                overlayY: overlayFallbackY,\n                offsetY: -offsetY\n            },\n            {\n                originX: originFallbackX,\n                originY: originFallbackY,\n                overlayX: overlayFallbackX,\n                overlayY: overlayFallbackY,\n                offsetY: -offsetY\n            }\n        ]);\n    };\n    /** Cleans up the active subscriptions. */\n    /**\n     * Cleans up the active subscriptions.\n     * @private\n     * @return {?}\n     */\n    MatMenuTrigger.prototype._cleanUpSubscriptions = /**\n     * Cleans up the active subscriptions.\n     * @private\n     * @return {?}\n     */\n    function () {\n        this._closingActionsSubscription.unsubscribe();\n        this._hoverSubscription.unsubscribe();\n    };\n    /** Returns a stream that emits whenever an action that should close the menu occurs. */\n    /**\n     * Returns a stream that emits whenever an action that should close the menu occurs.\n     * @private\n     * @return {?}\n     */\n    MatMenuTrigger.prototype._menuClosingActions = /**\n     * Returns a stream that emits whenever an action that should close the menu occurs.\n     * @private\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        /** @type {?} */\n        var backdrop = (/** @type {?} */ (this._overlayRef)).backdropClick();\n        /** @type {?} */\n        var detachments = (/** @type {?} */ (this._overlayRef)).detachments();\n        /** @type {?} */\n        var parentClose = this._parentMenu ? this._parentMenu.closed : of();\n        /** @type {?} */\n        var hover = this._parentMenu ? this._parentMenu._hovered().pipe(filter(function (active) { return active !== _this._menuItemInstance; }), filter(function () { return _this._menuOpen; })) : of();\n        return merge(backdrop, parentClose, hover, detachments);\n    };\n    /** Handles mouse presses on the trigger. */\n    /**\n     * Handles mouse presses on the trigger.\n     * @param {?} event\n     * @return {?}\n     */\n    MatMenuTrigger.prototype._handleMousedown = /**\n     * Handles mouse presses on the trigger.\n     * @param {?} event\n     * @return {?}\n     */\n    function (event) {\n        if (!isFakeMousedownFromScreenReader(event)) {\n            // Since right or middle button clicks won't trigger the `click` event,\n            // we shouldn't consider the menu as opened by mouse in those cases.\n            this._openedBy = event.button === 0 ? 'mouse' : null;\n            // Since clicking on the trigger won't close the menu if it opens a sub-menu,\n            // we should prevent focus from moving onto it via click to avoid the\n            // highlight from lingering on the menu item.\n            if (this.triggersSubmenu()) {\n                event.preventDefault();\n            }\n        }\n    };\n    /** Handles key presses on the trigger. */\n    /**\n     * Handles key presses on the trigger.\n     * @param {?} event\n     * @return {?}\n     */\n    MatMenuTrigger.prototype._handleKeydown = /**\n     * Handles key presses on the trigger.\n     * @param {?} event\n     * @return {?}\n     */\n    function (event) {\n        /** @type {?} */\n        var keyCode = event.keyCode;\n        if (this.triggersSubmenu() && ((keyCode === RIGHT_ARROW && this.dir === 'ltr') ||\n            (keyCode === LEFT_ARROW && this.dir === 'rtl'))) {\n            this.openMenu();\n        }\n    };\n    /** Handles click events on the trigger. */\n    /**\n     * Handles click events on the trigger.\n     * @param {?} event\n     * @return {?}\n     */\n    MatMenuTrigger.prototype._handleClick = /**\n     * Handles click events on the trigger.\n     * @param {?} event\n     * @return {?}\n     */\n    function (event) {\n        if (this.triggersSubmenu()) {\n            // Stop event propagation to avoid closing the parent menu.\n            event.stopPropagation();\n            this.openMenu();\n        }\n        else {\n            this.toggleMenu();\n        }\n    };\n    /** Handles the cases where the user hovers over the trigger. */\n    /**\n     * Handles the cases where the user hovers over the trigger.\n     * @private\n     * @return {?}\n     */\n    MatMenuTrigger.prototype._handleHover = /**\n     * Handles the cases where the user hovers over the trigger.\n     * @private\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        // Subscribe to changes in the hovered item in order to toggle the panel.\n        if (!this.triggersSubmenu()) {\n            return;\n        }\n        this._hoverSubscription = this._parentMenu._hovered()\n            // Since we might have multiple competing triggers for the same menu (e.g. a sub-menu\n            // with different data and triggers), we have to delay it by a tick to ensure that\n            // it won't be closed immediately after it is opened.\n            .pipe(filter(function (active) { return active === _this._menuItemInstance && !active.disabled; }), delay(0, asapScheduler))\n            .subscribe(function () {\n            _this._openedBy = 'mouse';\n            // If the same menu is used between multiple triggers, it might still be animating\n            // while the new trigger tries to re-open it. Wait for the animation to finish\n            // before doing so. Also interrupt if the user moves to another item.\n            if (_this.menu instanceof MatMenu && _this.menu._isAnimating) {\n                // We need the `delay(0)` here in order to avoid\n                // 'changed after checked' errors in some cases. See #12194.\n                _this.menu._animationDone\n                    .pipe(take(1), delay(0, asapScheduler), takeUntil(_this._parentMenu._hovered()))\n                    .subscribe(function () { return _this.openMenu(); });\n            }\n            else {\n                _this.openMenu();\n            }\n        });\n    };\n    /** Gets the portal that should be attached to the overlay. */\n    /**\n     * Gets the portal that should be attached to the overlay.\n     * @private\n     * @return {?}\n     */\n    MatMenuTrigger.prototype._getPortal = /**\n     * Gets the portal that should be attached to the overlay.\n     * @private\n     * @return {?}\n     */\n    function () {\n        // Note that we can avoid this check by keeping the portal on the menu panel.\n        // While it would be cleaner, we'd have to introduce another required method on\n        // `MatMenuPanel`, making it harder to consume.\n        if (!this._portal || this._portal.templateRef !== this.menu.templateRef) {\n            this._portal = new TemplatePortal(this.menu.templateRef, this._viewContainerRef);\n        }\n        return this._portal;\n    };\n    MatMenuTrigger.decorators = [\n        { type: Directive, args: [{\n                    selector: \"[mat-menu-trigger-for], [matMenuTriggerFor]\",\n                    host: {\n                        'aria-haspopup': 'true',\n                        '[attr.aria-expanded]': 'menuOpen || null',\n                        '(mousedown)': '_handleMousedown($event)',\n                        '(keydown)': '_handleKeydown($event)',\n                        '(click)': '_handleClick($event)',\n                    },\n                    exportAs: 'matMenuTrigger'\n                },] },\n    ];\n    /** @nocollapse */\n    MatMenuTrigger.ctorParameters = function () { return [\n        { type: Overlay },\n        { type: ElementRef },\n        { type: ViewContainerRef },\n        { type: undefined, decorators: [{ type: Inject, args: [MAT_MENU_SCROLL_STRATEGY,] }] },\n        { type: MatMenu, decorators: [{ type: Optional }] },\n        { type: MatMenuItem, decorators: [{ type: Optional }, { type: Self }] },\n        { type: Directionality, decorators: [{ type: Optional }] },\n        { type: FocusMonitor }\n    ]; };\n    MatMenuTrigger.propDecorators = {\n        _deprecatedMatMenuTriggerFor: [{ type: Input, args: ['mat-menu-trigger-for',] }],\n        menu: [{ type: Input, args: ['matMenuTriggerFor',] }],\n        menuData: [{ type: Input, args: ['matMenuTriggerData',] }],\n        restoreFocus: [{ type: Input, args: ['matMenuTriggerRestoreFocus',] }],\n        menuOpened: [{ type: Output }],\n        onMenuOpen: [{ type: Output }],\n        menuClosed: [{ type: Output }],\n        onMenuClose: [{ type: Output }]\n    };\n    return MatMenuTrigger;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar MatMenuModule = /** @class */ (function () {\n    function MatMenuModule() {\n    }\n    MatMenuModule.decorators = [\n        { type: NgModule, args: [{\n                    imports: [\n                        CommonModule,\n                        MatCommonModule,\n                        MatRippleModule,\n                        OverlayModule,\n                    ],\n                    exports: [MatMenu, MatMenuItem, MatMenuTrigger, MatMenuContent, MatCommonModule],\n                    declarations: [MatMenu, MatMenuItem, MatMenuTrigger, MatMenuContent],\n                    providers: [MAT_MENU_SCROLL_STRATEGY_FACTORY_PROVIDER]\n                },] },\n    ];\n    return MatMenuModule;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\nexport { MAT_MENU_SCROLL_STRATEGY, MatMenuModule, MatMenu, MAT_MENU_DEFAULT_OPTIONS, MatMenuItem, MatMenuTrigger, matMenuAnimations, fadeInItems, transformMenu, MatMenuContent, MAT_MENU_DEFAULT_OPTIONS_FACTORY as a24, MatMenuItemBase as b24, _MatMenuItemMixinBase as c24, MAT_MENU_PANEL as f24, MAT_MENU_SCROLL_STRATEGY_FACTORY as d24, MAT_MENU_SCROLL_STRATEGY_FACTORY_PROVIDER as e24 };\n//# sourceMappingURL=menu.es5.js.map\n"],"sourceRoot":""}